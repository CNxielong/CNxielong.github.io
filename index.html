<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JAVA基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/11/JAVA基础/" class="article-date">
  <time datetime="2019-03-11T14:44:09.000Z" itemprop="datePublished">2019-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/11/JAVA基础/">JAVA基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h2><p>标签（空格分隔）： JAVA后端</p>
<h2 id="参考资料-《JAVA核心技术-卷I》"><a href="#参考资料-《JAVA核心技术-卷I》" class="headerlink" title="参考资料:《JAVA核心技术 卷I》"></a>参考资料:《JAVA核心技术 卷I》</h2><h3 id="第一章-JDK安装、快捷键、JAVA语言特点"><a href="#第一章-JDK安装、快捷键、JAVA语言特点" class="headerlink" title="第一章  JDK安装、快捷键、JAVA语言特点"></a>第一章  JDK安装、快捷键、JAVA语言特点</h3><h4 id="1-计算机的体系结构-熟悉"><a href="#1-计算机的体系结构-熟悉" class="headerlink" title="1.计算机的体系结构(熟悉)"></a>1.计算机的体系结构(熟悉)</h4><h4 id="2-Java语言的概述-熟悉"><a href="#2-Java语言的概述-熟悉" class="headerlink" title="2.Java语言的概述(熟悉)"></a>2.Java语言的概述(熟悉)</h4><h5 id="1-1-Java语言的背景"><a href="#1-1-Java语言的背景" class="headerlink" title="1.1 Java语言的背景"></a>1.1 Java语言的背景</h5><p>   Java语言诞生于1995年，在编程语言排行榜占据重要的地位。<br>   Java语言之父是高斯林，以前隶属于sun公司，现在隶属于oracle-sun公司(甲骨文)。</p>
<h5 id="1-2-Java语言的主要版本"><a href="#1-2-Java语言的主要版本" class="headerlink" title="1.2 Java语言的主要版本"></a>1.2 Java语言的主要版本</h5><p>(1)Java SE版本</p>
<ul>
<li>Java Platform, Standard Edition）称之为“Java平台标准版”。</li>
<li>主要用于编写桌面应用程序。<br>(2)Java EE版本</li>
<li>Java Platform，Enterprise Edition）称之为“Java平台企业版”。   </li>
<li>主要用于编写具有B/S结构的电子商务网站、门户网站以及电信计费系统等。<br>(3)Java ME版本</li>
<li>Java Platform，Micro Edition）称之为Java 平台微型版。  </li>
<li><p>随着Android系统的普及，该技术已经走向淘汰。</p>
<h4 id="2-开发环境的搭建和使用-重点"><a href="#2-开发环境的搭建和使用-重点" class="headerlink" title="2.开发环境的搭建和使用(重点)"></a>2.开发环境的搭建和使用(重点)</h4><h5 id="3-1-jdk的下载和安装"><a href="#3-1-jdk的下载和安装" class="headerlink" title="3.1 jdk的下载和安装"></a>3.1 jdk的下载和安装</h5><p>(1)jdk的下载<br>下载方式一：直接去官网下载 - ww.sun.com/<a href="http://www.oracle.com" target="_blank" rel="noopener">www.oracle.com</a><br>下载方式二：直接用谷歌/百度/搜狗搜索 jdk1.7 64位 下载和安装<br>(2)jdk的安装<br>若下载的是绿色版，则直接解压即可。<br>若下载的是安装版，根据提示一步步点击下一步即可，切记不要有中文路径。</p>
<h5 id="3-2-相关的概念"><a href="#3-2-相关的概念" class="headerlink" title="3.2 相关的概念"></a>3.2 相关的概念</h5><p>javac.exe - Java语言的编译器，用于将高级源代码文件翻译成字节码文件。<br>java.exe  - Java语言的解释器，用于启动java虚拟机进行字节码文件的解释并执行<br>jre - Java运行时环境信息，只要运行java程序就必须安装jre。<br>jdk - Java开发工具包，只要编写/开发Java语言程序就必须安装jdk，jdk自带jre。<br>JVM - Java虚拟机，并不是真实存在的主机，作为java程序和计算机之间的桥梁。</p>
<h5 id="3-3-环境变量的概念和配置"><a href="#3-3-环境变量的概念和配置" class="headerlink" title="3.3 环境变量的概念和配置"></a>3.3 环境变量的概念和配置</h5><p>(1)基本概念<br>环境变量就是指用于存放环境信息并且数值可以改变的量。<br>通常情况下若启动一个可执行文件需要增加路径才可以，当把路径放入环境变量中后，只需要通过可执行文件的名称就可以启动该程序。<br>(2)配置方式<br>计算机 =&gt; 右键，选择属性 =&gt; 高级系统设置 =&gt; 高级 =&gt; 环境变量 =&gt; 系统变量 =&gt; 找到Path变量点击编辑，将javac.exe所在的路径信息加入到该变量值的最前面，添加英文版的分号 =&gt; 一路点击确定即可。<br>切记Path变量值原来的内容不要改动，以避免带来灾难性的后果！！！</p>
<h5 id="3-4-Java程序的开发流程"><a href="#3-4-Java程序的开发流程" class="headerlink" title="3.4 Java程序的开发流程"></a>3.4 Java程序的开发流程</h5><p>(1)新建文本文档，将默认的xxx.txt重命名为xxx.java。<br>(2)使用记事本的方式打开该文件，并编写Java代码保存。<br>(3)启动dos窗口，使用cd命令将路径切换到xxx.java所在的目录中。<br>(4)使用javac编译器根据xxx.java生成xxx.class文件。<br>(5)使用java xxx解释并执行该文件。 </p>
<h5 id="3-5-常用的快捷键"><a href="#3-5-常用的快捷键" class="headerlink" title="3.5 常用的快捷键"></a>3.5 常用的快捷键</h5><p>ctrl+s  - 保存<br>ctrl+a  - 全选<br>ctrl+c  - 复制<br>ctrl+x  - 剪切<br>ctrl+v  - 粘贴<br>ctrl+f  - 查找<br>ctrl+z  - 撤销<br>alt+tab - 切换任务窗口<br>windows+tab - 切换任务窗口<br>windows+d   - 显示桌面<br>windows+e   - 打开计算机的磁盘界面<br>windows+l   - 实现锁屏<br>windows+r   - 启动运行窗口，输入cmd再回车启动dos窗口<br>ctrl+alt+delete - 启动任务管理器<br>使用shift键可以进行中英文的切换。</p>
<h5 id="3-6-常用的dos命令"><a href="#3-6-常用的dos命令" class="headerlink" title="3.6 常用的dos命令"></a>3.6 常用的dos命令</h5><p>d:  - 表示切换到D盘<br>cd 目录名 - 表示切换到指定的目录中<br>cls - 表示清屏<br>dir  - 表示查看当前目录中的所有内容<br>cd .. - 表示切换到上一级目录</p>
<h5 id="3-7-Java语言的特点"><a href="#3-7-Java语言的特点" class="headerlink" title="3.7 Java语言的特点"></a>3.7 Java语言的特点</h5><p>(1)Java语言是一门纯面向对象的编程语言。<br>(2)Java语言具有跨平台的特性，也就是同一份字节码文件可以在不同的平台上执行，<br>是因为有Java虚拟机负责翻译工作。<br>(3)Java语言具有自动垃圾回收机制。</p>
</li>
</ul>
<h3 id="第二章-变量和注释、数据类型及转换、运算符、编码"><a href="#第二章-变量和注释、数据类型及转换、运算符、编码" class="headerlink" title="第二章   变量和注释、数据类型及转换、运算符、编码"></a>第二章   变量和注释、数据类型及转换、运算符、编码</h3><h4 id="X-JAVA中堆栈和内存分配-重点"><a href="#X-JAVA中堆栈和内存分配-重点" class="headerlink" title="X.JAVA中堆栈和内存分配(重点)"></a>X.JAVA中堆栈和内存分配(重点)</h4><ul>
<li><p><strong>RAM：RamdomAccessMemory随机存取存储器，断电丢失</strong></p>
<ul>
<li><ol>
<li>寄存器：最快的存储区,由编译器根据需求进行分配,我们在程序中无法控制。</li>
</ol>
</li>
<li><ol start="2">
<li>栈：存放基本类型的变量数据和对象的引用以及方法参数，但对象本身不存放在栈中，而是存放在堆（new出来的对象）或者常量池中（字符串常量对象存放在常量池中。）</li>
</ol>
</li>
<li><ol start="3">
<li>堆：存放所有new出来的对象。</li>
</ol>
</li>
<li><ol start="4">
<li>静态域：存放静态成员（static定义的）</li>
</ol>
</li>
<li><ol start="5">
<li>常量池：存放字符串常量和基本类型常量（public static final）。</li>
</ol>
</li>
</ul>
</li>
<li><strong>ROM：Read Only Memory只读存储器断电不丢失，用得少</strong> <ul>
<li><ol start="6">
<li>非RAM存储：硬盘（<strong>HDD</strong>是外存储器不是ROM）等永久存储空间</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><a href="https://www.cnblogs.com/happyPawpaw/p/4443323.html" target="_blank" rel="noopener">参考链接:</a><br><a href="https://www.cnblogs.com/happyPawpaw/p/4443323.html" target="_blank" rel="noopener">https://www.cnblogs.com/happyPawpaw/p/4443323.html</a></p>
<h4 id="X-JAVA中引用、对象和指针-以及C语言中变量、变量名、变量地址、指针、引用"><a href="#X-JAVA中引用、对象和指针-以及C语言中变量、变量名、变量地址、指针、引用" class="headerlink" title="X.JAVA中引用、对象和指针 以及C语言中变量、变量名、变量地址、指针、引用"></a><strong>X.JAVA中引用、对象和指针 以及C语言中变量、变量名、变量地址、指针、引用</strong></h4><ul>
<li>可以认为Java中的引用就是指针，是一种限制的指针，不能参与整数运行和指向任意位置的内存，并且不用显示回收对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java Code</span><br><span class="line"></span><br><span class="line">Person p = <span class="keyword">new</span> Person(); <span class="comment">//创建了一个Person实例，也被称为Person对象，这个Person对象被赋给p变量</span></span><br><span class="line"><span class="comment">//将p变量的值赋给p2</span></span><br><span class="line">Person p2 = p;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序中定义的Person类型的变量实际上是一个引用，它被存放在栈内存里，指向实际的Person对象；而真正的Person对象则存在在堆(heap)内存中。</li>
</ul>
<p><strong>c 中变量、变量名、变量地址、指针、引用:</strong></p>
<ul>
<li>变量，就是一个房间，它有编号（地址），他有名字（变量名），他有内容（里面的人）、</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">变量：存放3的那个内存空间</span><br><span class="line">变量名： a</span><br><span class="line">变量地址：0x12345678</span><br><span class="line">指针： *pi 指针（地址为值的变量就是指针变量） pi指针名 内容0x12345678</span><br><span class="line">引用： int&amp; 就是引用类型，int&amp; b = a;</span><br><span class="line">       意思就是b是对a引用，也就是b是a的别名、a就是b，b就是a</span><br><span class="line"></span><br><span class="line">    int a = 3; // a 是名字，3 是内容，地址可以假设是0x 12345678 (通常就是32位地址)、0x12345678 这个房间里面住的是一个int。</span><br><span class="line"></span><br><span class="line">    int *pi = &amp;a; // pi 是名字，内容就是a的地址，0x12345678; 所以，你懂的，</span><br><span class="line">    *pi = 4; // 就是通过pi，也就是a 的地址，把a的内容改成4了、</span><br><span class="line"></span><br><span class="line">    int &amp; b = a; // 同样的0x12345678 这个房间，刚才他有个名字a，现在又有个名字b了、</span><br><span class="line">    </span><br><span class="line">    b = 10; // 也就是 a = 10;</span><br><span class="line">    </span><br><span class="line">    a = 100; // 也就是 b = 100;</span><br><span class="line">    </span><br><span class="line">    int&amp; 就是引用类型，int&amp; b = a;</span><br><span class="line">    </span><br><span class="line">    意思就是b是对a 引用，也就是b 是a 的别名、a就是b，b就是a</span><br><span class="line">    </span><br><span class="line">    - pi 的类型int*, pi就是个指针（变量）、好吧，变量的别名，就相当于外号，</span><br></pre></td></tr></table></figure>
<h4 id="1-变量和注释-重点"><a href="#1-变量和注释-重点" class="headerlink" title="1.变量和注释(重点)"></a>1.变量和注释(重点)</h4><h5 id="1-1-变量（域）的基本概念以及分类"><a href="#1-1-变量（域）的基本概念以及分类" class="headerlink" title="1.1 变量（域）的基本概念以及分类"></a>1.1 变量（域）的基本概念以及分类</h5><p><a href="http://blog.chinaunix.net/uid-26434689-id-3328442.html" target="_blank" rel="noopener">参考链接:</a><br><a href="http://blog.chinaunix.net/uid-26434689-id-3328442.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-26434689-id-3328442.html</a></p>
<ul>
<li>变量（域/field）： <ul>
<li>当需要在程序中记录一个数据内容时，则需要声明一个变量来保存，变量本质上就是内存条中的一块区域。</li>
<li>由于记录的数据内容不同导致所需要的内存空间大小不同，在Java语言使用数据类型加以描述，而使用变量名来描述该内存空间的地址信息。</li>
</ul>
</li>
</ul>
<p><strong>变量分类</strong>：按照被声明位置划分：局部变量、成员变量（也叫“实例变量”、“域”）、 静态变量（也叫类变量）。</p>
<p><strong>静态变量</strong>（也叫类变量）是类中独立于方法之外的变量，用static 修饰。（static表示“全局的”、“静态的”，用来修饰成员变量和成员方法，或静态代码块（静态代码块独立于类成员，jvm加载类时会执行静态代码块，每个代码块只执行一次，按顺序执行））。<br><strong>成员变量</strong>（也叫“实例变量”、“域”）也是类中独立于方法之外的变量，不过没有static修饰。<br><strong>局部变量</strong>是类的方法中的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">看下面的伪代码说明：</span><br><span class="line">public class Variable&#123; 类名</span><br><span class="line">     static int allClicks=0;//静态变量也叫类变量</span><br><span class="line">     String str=&quot;hello world&quot;;//实例变量也叫成员变量</span><br><span class="line">     public void method()&#123; 方法名</span><br><span class="line">        int i =0;//局部变量</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员变量也称为:“域”，“实例变量”，在实体类或数据类中被称为“属性”或“字段”。当成员变量可以改变时，被称为对象的状态。<br>常量：用final修饰，值一旦给定就不能修改。const（C++定义常量）在JAVA中不使用但是作为保留字。<br><strong>Java变量和对象的作用域</strong>：<br><a href="https://www.cnblogs.com/AlanLee/p/6627949.html" target="_blank" rel="noopener">参考链接:</a><br><a href="https://www.cnblogs.com/AlanLee/p/6627949.html" target="_blank" rel="noopener">https://www.cnblogs.com/AlanLee/p/6627949.html</a>  </p>
<h5 id="1-2-变量的声明和初始化"><a href="#1-2-变量的声明和初始化" class="headerlink" title="1.2 变量的声明和初始化"></a>1.2 变量的声明和初始化</h5><p>   数据类型 变量名 = 初始值;   - 其中=初始值是可以省略的，但分号不可以省略<br>如：<br>   int id = 1001; - 推荐使用该方式<br>   int id;<br>注意：C++区分定义（extern）和声明,JAVA不区分。</p>
<h5 id="1-3-使用变量的注意事项"><a href="#1-3-使用变量的注意事项" class="headerlink" title="1.3 使用变量的注意事项"></a>1.3 使用变量的注意事项</h5><p>  (1)使用变量之前必须声明。<br>  (2)使用变量之前必须指定初始值。<br>  (3)不允许声明同名的变量。<br>  (4)每个变量都拥有自己独立的作用域(有效的范围)。<br>补充：<br>   在方法体中声明的变量叫做局部变量，局部变量的作用域为：声明开始到方法体结束</p>
<h5 id="1-4-标识符-变量名-的命名规则"><a href="#1-4-标识符-变量名-的命名规则" class="headerlink" title="1.4 标识符(变量名)的命名规则"></a>1.4 标识符(变量名)的命名规则</h5><p>  (1)必须由字母、数字、下划线_以及美元$组成，其中数字不能开头。<br>     如：id、name、name2等。<br>  (2)不能使用Java语言中的关键字/保留字，也就是Java语言中用来代表特殊含义的单词<br>     如：class、public、void、int等<br>  (3)区分大小写，长度没有限制但不宜过长。<br>     如：day 和 Day代表不同的标识符，不推荐使用。<br>  (4)尽量使用英文单词的组合做到见名知意，虽然支持中文，但不推荐使用。<br>     如：sendMsgToAll、minute、time、length  年龄</p>
<h5 id="1-5-常见的编程规范"><a href="#1-5-常见的编程规范" class="headerlink" title="1.5 常见的编程规范"></a>1.5 常见的编程规范</h5><p>  (1)尽量使用空格、缩进以及空行来提高代码的可读性和层次感。<br>  (2)当类名由多个单词组成时，要求每个单词的首字母都要大写。<br>  (3)当变量名由多个单词组成时，要求从第二个单词起每个单词的首字母要大写。</p>
<h5 id="1-6-注释"><a href="#1-6-注释" class="headerlink" title="1.6 注释"></a>1.6 注释</h5><p>   单行注释 - 从//开始一直到本行的末尾之间的内容都是注释内容。<br>   多行注释 - 从/<em>开始一直到</em>/结尾之间的内容都是注释内容。<br>   其中多行注释要求不允许嵌套使用，如：/<em> /</em> <em>/ </em>/ 是错误的。</p>
<h5 id="1-7-作用域"><a href="#1-7-作用域" class="headerlink" title="1.7 作用域"></a>1.7 作用域</h5><p><a href="https://www.cnblogs.com/AlanLee/p/6627949.html" target="_blank" rel="noopener">参考链接: </a>  <a href="https://www.cnblogs.com/AlanLee/p/6627949.html" target="_blank" rel="noopener">https://www.cnblogs.com/AlanLee/p/6627949.html</a></p>
<h4 id="2-数据类型-重点"><a href="#2-数据类型-重点" class="headerlink" title="2.数据类型(重点)"></a>2.数据类型(重点)</h4><h5 id="2-1-数据类型的分类"><a href="#2-1-数据类型的分类" class="headerlink" title="2.1 数据类型的分类"></a>2.1 数据类型的分类</h5><p>  在Java语言中将数据类型分为两大类：基本数据类型 和 引用数据类型。<br>  其中基本数据类型主要有(8种)：<br>      byte/short/int/long - 用于描述整数数据的类型，如：666。<br>      float/double        - 用于描述小数数据的类型，如：3.14。<br>      char                - 用于描述字符数据的类型，如：’a’。<br>      boolean             - 用于描述真假信息的类型，如：true 和 false。<br>  其中引用数据类型主要有：<br>      数组、类、接口、枚举以及标注(了解)。</p>
<h5 id="2-2-常用的进制-数学、理解基本数据类型"><a href="#2-2-常用的进制-数学、理解基本数据类型" class="headerlink" title="2.2 常用的进制(数学、理解基本数据类型)"></a>2.2 常用的进制(数学、理解基本数据类型)</h5><p>  日常生活中采用十进制加以描述，逢十进一，权重为：10^0 10^1 10^2 …<br>  计算机中采用二进制加以描述，逢二进一，权重为：2^0 2^1 2^2 …<br>  八进制和十六进制为了简化二进制的表示形式。<br>  在计算机中采用二进制的最高位(最左边)来代表符号位，若该位是0则表示非负数，若该位是1则表示负数。</p>
<h5 id="2-3-进制之间的转换-数学、理解基本数据类型"><a href="#2-3-进制之间的转换-数学、理解基本数据类型" class="headerlink" title="2.3 进制之间的转换(数学、理解基本数据类型)"></a>2.3 进制之间的转换(数学、理解基本数据类型)</h5><p>(1)十进制和二进制之间的转换(要求每个人掌握)<br>   a.正十进制转换为二进制的方式<br>     1)除2取余法，让十进制整数不断地除以2取出余数，直到商为0将所有余数逆序排列<br>     2)拆分法，将十进制整数拆分为若干个二进制权重的和，若该权重出现则下面写1，<br>               若该权重没有出现则下面写0(推荐)。<br>   如：12<br>       128 64 32 16    8 4 2 1       12 = 8 + 4<br>          0   0   0    0     1 1 0 0       12转换为二进制的结果是：0000 1100<br>   b.正二进制转换为十进制的方式<br>     1)加权法，让二进制的每个数字乘以当前位的权重最后相加。<br>   如：0000 1100<br>    0000 1100 =&gt; 0<em>2^7 + 0</em>2^6 + 0<em>2^5 + 0</em>2^4 + 1<em>2^3 + 1</em>2^2 + 0<em>2^1 + 0</em>2^0<br>              =&gt; 0 + 0 + 0 + 0 + 8 + 4 + 0 + 0<br>              =&gt; 12  </p>
<p>   c.负十进制转换为二进制的方式<br>     1)先将该整数的绝对值转换为二进制，然后进行按位取反再加1.<br>   如：-12<br>       12转换为二进制：0000 1100      12的二进制：0000 1100<br>       按位取反：      1111 0011     -12的二进制：1111 0100 +<br>       再加1:          1111 0100     ————————–<br>                                                1 0000 0000(最高位溢出)<br>   d.负二进制转换为十进制的方式<br>    1)先进行按位取反加1，然后转换为十进制整数，最后添加负号<br>   如：1111 0100<br>       1111 0100进行按位取反：0000 1011<br>       加1：                  0000 1100<br>       转换为十进制整数：     12<br>       最后添加负号：         -12</p>
<h3 id="2-3-1原码反码补码扩展："><a href="#2-3-1原码反码补码扩展：" class="headerlink" title="### 2.3.1原码反码补码扩展："></a>### 2.3.1原码反码补码扩展：</h3><p>原码、反码以及补码的概念。<br><a href="http://blog.csdn.net/u011080472/article/details/51280919" target="_blank" rel="noopener">http://blog.csdn.net/u011080472/article/details/51280919</a><br><a href="http://blog.csdn.net/liushuijinger/article/details/7429197" target="_blank" rel="noopener">http://blog.csdn.net/liushuijinger/article/details/7429197</a><br>机器数：一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号， 正数为0，负数为1。<br>真值：将带符号位的机器数对应的真正数值称为机器数的真值。<br>例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1<br>原码：如果机器字长为n，那么一个数的原码就是用一个n位的二进制数，其中最高位为符号位：正数为0，负数为1。剩下的n-1位表示概数的绝对值。<br>例如： X=+101011 , [X]原= 00101011    X=-101011 , [X]原= 10101011<br>位数不够的用0补全。<br>PS：正数的原、反、补码都一样：0的原码跟反码都有两个，因为这里0被分为+0和-0。<br>反码：反码就是在原码的基础上，符号位不变其他位按位取反(就是0变1，1变0)。<br>补码：<br>补码就是在反码的基础上按照正常的加法运算加1。<br>例如：X=-101011 , [X]原= 10101011 ，[X]反=11010100，[X]补=11010101<br>PS：0的补码是唯一的，如果机器字长为8那么[0]补=00000000。</p>
<p>移码：<br>移码最简单了，不管正负数，只要将其补码的符号位取反即可。<br>例如：X=-101011 , [X]原= 10101011 ，[X]反=11010100，[X]补=11010101，[X]移=01010101</p>
<p>(2)八进制和二进制之间的转换(熟悉)<br>   a.二进制转换为八进制的方式<br>     1)将每三位二进制合并为一位八进制，并使用0作为前缀代表八进制。<br>    如：<br>       010 110  =&gt; 026<br>   b.八进制转换为二进制的方式<br>     1)将每一位八进制拆分为三位二进制，并使用0b作为前缀代表二进制(jdk1.7)。<br>    如：<br>       075 =&gt; 0b111 101 </p>
<p>(3)十六进制和二进制之间的转换(熟悉)<br>   a.二进制转换为十六进制的方式<br>    1)将每四位二进制合并为一位十六进制，并使用0x作为前缀代表十六进制。<br>    如：<br>       1010 0011 =&gt; 0xa3(十六进制中使用a~f来代表10 ~ 15).<br>   b.十六进制转换为二进制的方式<br>    1)将每一位十六进制拆分为四位二进制，并使用0b作为前缀代表二进制。<br>    如：<br>       0xab =&gt; 0b1010 1011</p>
<h5 id="2-4-单个字节表示的整数范围-重中之重"><a href="#2-4-单个字节表示的整数范围-重中之重" class="headerlink" title="2.4 单个字节表示的整数范围(重中之重)"></a>2.4 单个字节表示的整数范围(重中之重)</h5><pre><code>在计算机中单个字节表示八位二进制位，最高位(最左边)的二进制位代表符号位，若该位是0则表示非负数，若该位是1则表示负数，具体如下：
非负数的表示范围是：0000 0000 ~ 0111 1111  =&gt; 0 ~ 127 =&gt; 0 ~ 2^7-1  
</code></pre><p>其中0000 0000转换为十进制整数就是0;<br>其中0111 1111转换为十进制整数：64 + 32 + 16 + 8 + 4 + 2 + 1 = 127;<br>    负数的表示范围是：  1000 0000 ~ 1111 1111 =&gt; -128 ~ -1 =&gt; -2^7 ~ -2^0<br>其中1000 0000转换为十进制整数：<br>    按位取反：0111 1111  =&gt; 加1：1000 0000 =&gt; 128  =&gt; -128;<br>其中1111 1111转换为十进制整数：<br>    按位取反：0000 0000  =&gt; 加1：0000 0001 =&gt; 1    =&gt; -1;</p>
<p>综上所述：<br>    对于单个字节的二进制来说，所能表示的十进制整数范围是：-128 ~ 127.<br>                                                          -2^7 ~ 2^7-1.</p>
<h5 id="2-5-整数类型"><a href="#2-5-整数类型" class="headerlink" title="2.5 整数类型"></a>2.5 整数类型</h5><p>   在Java语言中用于描述整数的类型有：byte/short/int/long，推荐使用int类型。<br>   其中byte类型在内存空间占1个字节的大小，表示范围是：-128 ~ 127(-2^7 ~ 2^7-1)<br>   其中short类型在内存空间占2个字节的大小，表示范围是：-2^15 ~ 2^15-1。<br>                                                       (-32768 ~ 32767)。<br>   其中int类型在内存空间占4个字节的大小，表示范围是：-2^31 ~ 2^31-1.<br>                                                       (正负二十一亿之间)<br>   其中long类型在内存空间占8个字节的大小，表示范围是：-2^63 ~ 2^63-1.<br>                                                       (比int类型范围还大)<br>   在程序中直接写出的整数数值叫做 直接量/常量/字面值，默认为int类型，如：666，若希望表示long类型的直接量，则需要在直接量的后面加上L或者l，推荐使用L。</p>
<p>扩展：<br>   若希望表示比long类型范围还大的整数，则借助java.math.BigInteger类。</p>
<h5 id="2-6-浮点类型"><a href="#2-6-浮点类型" class="headerlink" title="2.6 浮点类型"></a>2.6 浮点类型</h5><p>   在Java语言中用于描述小数数据的类型有：float/double，推荐使用double类型。<br>   其中float类型在内存空间中占4个字节的大小，叫做单精度浮点数。<br>   其中double类型在内存空间中占8个字节的大小，叫做双精度浮点数。<br>   在程序中直接写入的小数数据叫做直接量/常量/字面值，默认为double类型，若希望表示float类型的直接量，则需要在直接量的后面增加F或者f。</p>
<p>Float double扩展：<br>   float类型和double类型是不能实现精确计算的，为了得到精确的结果需要借助java.math.BigDecimal类加以描述。<br>   有余力的同学课下可以查询float和double存储结构。<br><a href="http://blog.csdn.net/zq602316498/article/details/41148063" target="_blank" rel="noopener">http://blog.csdn.net/zq602316498/article/details/41148063</a><br>float：4字节 32位<br>        1bit（符号位） 8bits（指数位） 23bits（尾数位）     a = r^3其中r为底数 3是指数<br>double：8字节 64位<br>        1bit（符号位） 11bits（指数位） 52bits（尾数位）</p>
<h5 id="2-7-布尔类型"><a href="#2-7-布尔类型" class="headerlink" title="2.7 布尔类型"></a>2.7 布尔类型</h5><p>  在Java语言中用于描述真假信息的类型有：boolean，该类型的数值：true 和 false.<br>  由于布尔类型只有两个数值因此使用一个二进位制就足够描述，但通常认为是1个字节</p>
<h5 id="2-8-字符类型-熟悉"><a href="#2-8-字符类型-熟悉" class="headerlink" title="2.8 字符类型(熟悉)"></a>2.8 字符类型(熟悉)</h5><p>  在Java语言中用于描述字符信息的类型有：char，在内存空间中占2个字节的大小，通常用于描述单个字符，如：’a’ ‘1’ ‘中’等。<br>  在现实生活中使用更多的是多个字符组成的字符串，使用String类型加以描述，并且使用双引号括起来，如：”xiaomage”。<br>  要求大家记住的ASCII数值有：<br>       ‘A’ - 65   ‘a’ - 97   ‘0’ - 48   空格 - 32   换行 - 10<br>  要求大家记住的转义字符有：<br>       \” - “   \’ - ‘   \  - \   \t - tab键  \n - 换行符 </p>
<h4 id="3-基本数据类型之间的转换-熟悉"><a href="#3-基本数据类型之间的转换-熟悉" class="headerlink" title="3.基本数据类型之间的转换(熟悉)"></a>3.基本数据类型之间的转换(熟悉)</h4><p>复习：<br>   Java语言基本数据类型有：byte、short、int、long、float、double、char boolean    byte b = 10;  - 10叫直接量，默认是int类型</p>
<p>   基本数据类型之间的转换分为：自动类型转换 和 强制类型转换。<br>   其中自动类型转换主要指：小范围向大范围之间的转换。<br>   其中强制类型转换主要指：大范围向小范围之间的转换。<br>       语法格式：目标类型 变量名 = (目标类型)源类型变量名;<br>              如：byte b1 = (byte)s1;</p>
<p>经验：<br>   当程序中出现大范围向小范围转换的代码时编译报错，若希望编译能够通过则需要按照上述方式进行强转，但强转带来的结果会改变原始数据，因此能不用则不用。<br>double sum = 0.0;     int i = 1;//sum如果声明为double则报错损失精度<br>        for(  i  =  1;  i  &lt;=  num;  i++  ){<br>        System.out.println(“数字:”+i);<br>        sum = sum + 1.0/i;(推荐) //sum =  sum + ((double)1)/i;;//也可以<br>        }</p>
<h4 id="4-运算符-重点"><a href="#4-运算符-重点" class="headerlink" title="4.运算符(重点)"></a>4.运算符(重点)</h4><h5 id="4-1-算数运算符"><a href="#4-1-算数运算符" class="headerlink" title="4.1 算数运算符"></a>4.1 算数运算符</h5><ul>
<li>表示加法运算符   - 表示减法运算符    * 表示乘法运算符    /  表示除法运算符<br>% 表示取模/取余运算符</li>
</ul>
<p>注意事项：<br>  (1)两个整数相除时结果取整数部分，丢弃小数部分。<br>  (2)若希望结果是浮点数据，则需要进行处理,方式如下：<br>      a.将其中一个操作数强转为double类型，则结果不会丢弃小数部分。<br>      b.将其中一个操作数乘以1.0提升为double类型，则结果不会丢失小数部分(推荐)<br>  (3)0不能做除数，0.0可以做除数，但结果是无穷大，因此以后编程不要使用0和0.0<br>     作为除数。</p>
<p>经验：<br>  运算符+ 既可以当做算数运算符处理，也可以当做字符串连接符处理，区分方式如下：<br>     a.当运算符+两侧的操作数都不是字符串时，则看做算数运算符处理。<br>     b.当运算符+两侧的操作数中只要有一个是字符串时，则看做字符串连接符处理。<br>    System.out.println(100+200+”300”);//输出300300<br>    System.out.println(“300”+100+200); //输出300200100</p>
<h5 id="4-2-比较-关系运算符"><a href="#4-2-比较-关系运算符" class="headerlink" title="4.2 比较/关系运算符"></a>4.2 比较/关系运算符</h5><blockquote>
<p>表示是否大于  &gt;= 表示是否大于等于  &lt; 表示是否小于  &lt;= 表示是否小于等于<br>   == 表示是否等于  != 表示是否不等于</p>
</blockquote>
<p>   关系运算符参与的表达式结果为boolean类型，只有两种：true 和 false </p>
<h5 id="4-3-自增减运算符"><a href="#4-3-自增减运算符" class="headerlink" title="4.3 自增减运算符"></a>4.3 自增减运算符</h5><ul>
<li>表示加法运算符   ++ 表示自增运算符，也就是让变量自己的数值加1.</li>
</ul>
<ul>
<li>表示减法运算符   – 表示自减运算符，也就是让变量自己的数值减1.</li>
</ul>
<p>经验：<br>   在以后的编程中尽量单独使用自增减运算符，不要和其他运算符搭配使用，以避免错误的发生。如：ia++;</p>
<h5 id="4-4-逻辑运算符"><a href="#4-4-逻辑运算符" class="headerlink" title="4.4 逻辑运算符"></a>4.4 逻辑运算符</h5><p>   &amp;&amp; - 表示逻辑与运算符，相当于”并且”，同真为真，一假为假。<br>   || - 表示逻辑或运算符，相当于”或者”，一真为真，同假为假。<br>   !  - 表示逻辑非运算符，相当于”取反”，真为假，假为真。</p>
<p>短路特性：<br>    对于逻辑与运算符来说，若第一个条件为假则整个表达式的条件一定为假，此时第二个条件可以跳过不执行。<br>    对于逻辑或运算符来说，若第一个条件为真则整个表达式的条件一定为真，此时第二个条件可以跳过不执行。  </p>
<h5 id="4-5-条件-三目运算符"><a href="#4-5-条件-三目运算符" class="headerlink" title="4.5 条件/三目运算符"></a>4.5 条件/三目运算符</h5><p>   ?: - 条件/三目运算符<br>   条件表达式? 表达式1: 表达式2; </p>
<pre><code>- 判断条件条件表达式是否成立
     =&gt; 若成立，则执行表达式1;
     =&gt; 若不成立，则执行表达式2;
</code></pre><h5 id="4-6-赋值运算符"><a href="#4-6-赋值运算符" class="headerlink" title="4.6 赋值运算符"></a>4.6 赋值运算符</h5><p> (1)简单赋值<br>    =  表示将=右边的数据赋值给=左边的变量，去覆盖该变量原来的数值。<br>如：<br>    ia = 10;<br>    ia = ib = ic = 20;   =&gt;  ia、ib、ic最终的结果都是20.</p>
<p>笔试题：<br>   分析以下四种形式的区别？<br>       ia = 10;  - 将数据10赋值给ia，覆盖ia原来的数值。<br>       10 = ia;  - 编译报错<br>       ia == 10; - 判断ia是否等于10<br>       10 == ia; - 判断10是否等于ia</p>
<p>(2)复合赋值<br>   +=  -=  *=  /=  … …<br>如：<br>   ia = ia + 10;(推荐，可读性更强)<br>   =&gt;  ia += 10;    </p>
<p>笔试题：<br>   分析以下两种形式的区别？<br>   byte b1 = 5;  b1 += 2;     //ok<br>   byte b1 = 5;  b1 = b1 + 2; //error<br>解析：<br>   b1 += 2 真正等价的是：b1 = (byte)(b1 + 2);   </p>
<h5 id="4-7-移位运算符-了解"><a href="#4-7-移位运算符-了解" class="headerlink" title="4.7 移位运算符(了解)"></a>4.7 移位运算符(了解)</h5><p>   &lt;&lt;   表示左移运算符，也就是按照二进制位向左移动，右边添加0.</p>
<blockquote>
<blockquote>
<p>  表示右移运算符，也就是按照二进制位向右移动，左边添加符号位.</p>
<blockquote>
<p> 表示无符号右移运算符，也就是按照二进制位向右移动，左边添加0.</p>
</blockquote>
</blockquote>
</blockquote>
<h5 id="4-8-位运算符-了解"><a href="#4-8-位运算符-了解" class="headerlink" title="4.8 位运算符(了解)"></a>4.8 位运算符(了解)</h5><p>   &amp;   表示按位与运算符，同1为1，一0为0.(1看做真，0看做假)<br>   |   表示按位或运算符，同0为0，一1为1.<br>   ~   表示按位取反运算符，1为0,0为1.<br>   ^   表示按位异或运算符，相同为0，不同为1.</p>
<h5 id="4-9-运算符的优先级"><a href="#4-9-运算符的优先级" class="headerlink" title="4.9 运算符的优先级"></a>4.9 运算符的优先级</h5><p>   (1)()的优先级极高。<br>   (2) =的优先级极低。<br>   (3) * / % 的优先级高于 + -，同级的运算符(从左到右)哪个在前先算哪个。</p>
<h4 id="5-编码"><a href="#5-编码" class="headerlink" title="5.编码"></a>5.<a href="https://blog.csdn.net/longintchar/article/details/51079340" target="_blank" rel="noopener">编码</a></h4><h5 id="ASCII码"><a href="#ASCII码" class="headerlink" title="- ASCII码"></a>- ASCII码</h5><pre><code>- 所有的英文字母都对应到一个数字编码，这就是ASCII码（American Standard Code for Information Interchange）。ASCII码是很久很久以前（1968年）制定的。它只使用了一个8位字节中的低7位，总共是127个编码位。
</code></pre><h5 id="Unicode：编码标准"><a href="#Unicode：编码标准" class="headerlink" title="- Unicode：编码标准"></a>- Unicode：编码标准</h5><pre><code>- 十六位Unicode字符集，可以表示 2^16=65536个数目。而UTF-8,UTF-16，UTF-32是UNICODE在计算机中的不同存储方式。
</code></pre><h5 id="码点（code-point）："><a href="#码点（code-point）：" class="headerlink" title="- 码点（code point）："></a>- 码点（code point）：</h5><pre><code>- 一个编码表中的某个字符对应的代码值。
</code></pre><h5 id="字符集（charset）：计算机可以表示的字符组成了一个集合。"><a href="#字符集（charset）：计算机可以表示的字符组成了一个集合。" class="headerlink" title="- 字符集（charset）：计算机可以表示的字符组成了一个集合。"></a>- 字符集（charset）：计算机可以表示的字符组成了一个集合。</h5><pre><code>- 常见的字符集有Unicode，ASCII等。
</code></pre><h5 id="字符集编码-Character-encoding-："><a href="#字符集编码-Character-encoding-：" class="headerlink" title="- 字符集编码(Character encoding)："></a>- 字符集编码(Character encoding)：</h5><pre><code>- 而encoding则是一种映射工具，它将自然语言的字符和字符集进行配对。常见的字符集编码有UTF-8，GBK，Big5等。
</code></pre><h3 id="第三章-程序结构"><a href="#第三章-程序结构" class="headerlink" title="第三章  程序结构"></a>第三章  程序结构</h3><p>三种程序结构：顺序、分支、循环结构</p>
<h4 id="1-分支结构"><a href="#1-分支结构" class="headerlink" title="1.分支结构"></a>1.分支结构</h4><h5 id="1-1基本概念"><a href="#1-1基本概念" class="headerlink" title="1.1基本概念"></a>1.1基本概念</h5><p>   当需要进行条件的判断和选择时，需要使用分支结构来进行处理。</p>
<h5 id="1-2-if分支结构"><a href="#1-2-if分支结构" class="headerlink" title="1.2 if分支结构"></a>1.2 if分支结构</h5><p>(1)语法格式<br>   if(条件表达式){<br>      语句块1;<br>   }<br>   语句块2;</p>
<p>(2)执行流程<br>   判断条件表达式是否成立<br>       =&gt; 若成立，则执行语句块1;  =&gt; 执行语句块2;<br>       =&gt; 若不成立，则执行语句块2;<br>1.2.1 if-else分支结构<br>(1)语法格式<br>   if(条件表达式){<br>      语句块1;<br>   }<br>   else{<br>      语句块2;<br>   }<br>   语句块3;</p>
<p>(2)执行流程<br>   判断条件表达式是否成立<br>       =&gt; 若成立，则执行语句块1;  =&gt; 执行语句块3;<br>       =&gt; 若不成立，则执行语句块2; =&gt; 执行语句块3;<br>1.2.2 if-else if-else分支结构<br>(1)语法格式<br>   if(条件表达式1){<br>      语句块1;<br>   }<br>   else if(条件表达式2){<br>      语句块2;<br>   }<br>   … …<br>   else{<br>      语句块3;<br>   }<br>   语句块4;</p>
<p>(2)执行流程<br>   判断条件表达式1是否成立<br>       =&gt; 若成立，则执行语句块1 =&gt; 执行语句块4;<br>       =&gt; 若不成立，则判断条件表达式2是否成立<br>               =&gt; 若成立，则执行语句块2 =&gt; 执行语句块4;<br>               =&gt; 若不成立，则执行语句块3 =&gt; 执行语句块4;</p>
<h5 id="1-3-switch-case结构-熟悉"><a href="#1-3-switch-case结构-熟悉" class="headerlink" title="1.3 switch-case结构(熟悉)"></a>1.3 switch-case结构(熟悉)</h5><p>(1)语法结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">   switch(变量/表达式)&#123;// switch(byte、short、char、int、枚举、JAVA SE 7开始支持 String )</span><br><span class="line"></span><br><span class="line">       case 字面值1: 语句块1; break;</span><br><span class="line">       case 字面值2: 语句块2; break;</span><br><span class="line">       ... ...</span><br><span class="line">       default:语句块3;  </span><br><span class="line">   &#125;</span><br><span class="line">   语句块4;</span><br><span class="line">```   </span><br><span class="line">**警告:** 若不加break，会从满足case条件的语句一直执行,直到default语句执行完，退出循环。</span><br><span class="line">(2)执行流程</span><br><span class="line">   计算变量/表达式的结果 </span><br><span class="line">      =&gt; 判断结果是否等于字面值1  </span><br><span class="line">         =&gt; 若成立，则执行语句块1 =&gt; 执行break =&gt; 执行语句块4;</span><br><span class="line">         =&gt; 若不成立，则判断是否等于字面值2</span><br><span class="line">               =&gt; 若成立，则执行语句块2 =&gt; 执行break =&gt; 执行语句块4;</span><br><span class="line">               =&gt; 若不成立，则执行语句块3 =&gt; 执行语句块4;</span><br><span class="line"></span><br><span class="line">(3)注意事项</span><br><span class="line">   switch()中支持的类型：byte、short、char、int，从jdk1.5开始支持枚举类型，从jdk1.7开始支持String类型。</span><br><span class="line"> </span><br><span class="line">  #### 2.循环结构(重中之重)</span><br><span class="line">   ##### 2.1 基本概念</span><br><span class="line">   当需要重复做一件事时，可以使用循环结构来解决。</span><br><span class="line">   ##### 2.2 for循环 空语句</span><br><span class="line">(1)语法结构</span><br><span class="line">   for(表达式1; 条件表达式2; 表达式3)&#123;</span><br><span class="line">      语句块1;(循环体)</span><br><span class="line">   &#125;   </span><br><span class="line">   语句块2;</span><br><span class="line"></span><br><span class="line">(2)执行流程</span><br><span class="line">   执行表达式1 =&gt; 判断条件表达式2是否成立</span><br><span class="line">       =&gt; 若成立，则执行语句块1  =&gt; 执行表达式3 =&gt; 判断条件表达式2是否成立</span><br><span class="line">       =&gt; 若不成立，则执行语句块2</span><br><span class="line">(3)for(;;)格式：1.必须要有两个分号”;”2.里面的条件表达式能计算出正确结果就行</span><br><span class="line">(4)空语句：for(;;); 等同于for(;;)&#123;;&#125;括号里面只有“;”的语句，啥也不执行。</span><br><span class="line">   ##### 2.3 break和continue关键字</span><br><span class="line">实例：TestForBreakContinue.java  </span><br><span class="line">**break** 关键字用在循环和 if else 中表示跳出当前循环，用在switch-case结构表示跳出当前结构。</span><br><span class="line">**break 嵌套**：break 用于退出所在循环体。如果退出外层循环体，需要用标号的方式。</span><br></pre></td></tr></table></figure></p>
<pre><code>flag:
while(){
    for(;;){
        if() break;//跳出for当前循环
        if() break flag;//跳出flag标记 while循环
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**continue**</span><br></pre></td></tr></table></figure>
<pre><code>Scanner sc = new Scanner(System.in);
while (sum &lt; goal) {
    System.out.println(&quot;小伙子输入一个膜法值:&quot;);
    int num = sc.nextInt();
    if (n &lt; 0)    continue;//如果n&lt;0,跳过 sum += n;立刻跳回while循环首部
    sum += n;
}

Scanner sc = new Scanner(System.in);
for (int i = 0; i &lt; 10; i++) {
    System.out.println(&quot;小伙子输入一个膜法值:&quot;);
    int num = sc.nextInt();
    if (n &lt; 0) continue;//如果 n&lt;0 跳回i++
    sum += n;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ##### 2.4 特殊的循环</span><br><span class="line">for(;;) - 该循环中没有明确的循环条件，这样的循环叫做无限循环，俗称&quot;死循环&quot;。</span><br><span class="line">该循环通常情况下与break关键字搭配使用</span><br></pre></td></tr></table></figure>
<pre><code>for(;;){
    if(i&gt;3) break;
    i++;                    
}//i&gt;4的时候跳出循环
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   ##### 2.5 for循环嵌套</span><br><span class="line">1)语法格式</span><br></pre></td></tr></table></figure>
<p>   for(表达式1; 条件表达式2; 表达式3){<br>    //表达式1中变量作用域为For循环整个循环体<br>      for(表达式4; 条件表达式5; 表达式6){<br>          语句块7(循环体)；<br>      }<br>   }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(2)执行流程   </span><br><span class="line">   执行表达式1 =&gt; 判断条件表达式2是否成立</span><br><span class="line">      =&gt; 若成立，则执行表达式4 =&gt; 判断条件表达式5是否成立 </span><br><span class="line">            =&gt; 若成立，则执行语句块7 =&gt; 执行表达式6 =&gt; 判断条件表达式5是否成立</span><br><span class="line">            =&gt; 若不成立，则执行表达式3 =&gt; 判断条件表达式2是否成立</span><br><span class="line">     =&gt; 若不成立，则结束整个循环</span><br><span class="line"> ###  ### 2.5.1警告：</span><br></pre></td></tr></table></figure></p>
<p>for(表达式1; 条件表达式2; 表达式3); //表达式1中变量作用域为For循环整个循环体</p>
<pre><code>for (int i = 0; i != 1; i += 0.1) {
    System.out.printf(&quot;I的值:%4.2f&quot;, i);//编译不通过
</code></pre><p>// java.util.IllegalFormatConversionException: f != java.lang.Integer<br>    }</p>
<pre><code>for (double i = 0; i != 1; i += 0.1) {//死循环  double精度有误差
    System.out.printf(&quot;I的值:%4.2f &quot;, i);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">###  ### 2.5.2 for each：</span><br></pre></td></tr></table></figure>
<p>语句格式：for( variable : collection ) statement<br>variable:用于暂存集合collection中的每一个元素。<br>collection：必须是数组或者实现Iterable接口的类对象(ArrayList等)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">   ##### 2.6 while循环</span><br><span class="line">(1)语法格式</span><br><span class="line">   while(条件表达式)&#123;</span><br><span class="line">      循环体;</span><br><span class="line">   &#125; </span><br><span class="line">   语句块;</span><br><span class="line"></span><br><span class="line">(2)执行流程</span><br><span class="line">   判断条件表达式是否成立</span><br><span class="line">      =&gt; 若成立，则执行循环体 =&gt; 判断条件表达式是否成立</span><br><span class="line">      =&gt; 若不成立，则执行语句块;</span><br><span class="line"></span><br><span class="line">(3)注意事项</span><br><span class="line">   a.while循环和for循环是完全可以互换的。</span><br><span class="line">   b.while循环通常使用在明确循环条件但不明确循环次数的场合中。</span><br><span class="line">     for循环通常使用在明确循环次数/范围的场合中。</span><br><span class="line">   c.while(true)等价于for(;;)，都表示无限循环，俗称&quot;死循环&quot;。</span><br><span class="line"></span><br><span class="line">(4)while(boolean)格式：1.（）内可以使TRUE或者FALSE  2.可以是条件表达式，但是表达式结果只能是布尔类型。</span><br><span class="line">   ##### 2.7 do-while循环(熟悉)</span><br><span class="line">(1)语法格式</span><br><span class="line">   do&#123;</span><br><span class="line">      循环体;</span><br><span class="line">   &#125;while(条件表达式);//注意分号</span><br><span class="line">   语句块;</span><br><span class="line"></span><br><span class="line">(2)执行流程</span><br><span class="line">   执行循环体 =&gt; 判断条件表达式是否成立</span><br><span class="line">       =&gt; 若成立，则执行循环体 =&gt; 判断条件表达式是否成立</span><br><span class="line">       =&gt; 若不成立，则执行语句块</span><br><span class="line"></span><br><span class="line">(3)注意事项</span><br><span class="line">   a.do-while循环通常使用在至少执行一次循环体的场合中。</span><br><span class="line">   b.do-while循环的条件表达式后面有分号，其他循环没有。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ### 第四章  数组</span><br><span class="line">  #### 1.一维数组</span><br><span class="line">   ##### 1.1 基本概念</span><br><span class="line">![1.jpg-142kB][1]</span><br><span class="line">   变量本质上就是一块内存空间，用于记录单个数据，而且内容可以改变。</span><br><span class="line">   一维数组本质上就是一段连续的内存空间，用于记录多个数据类型相同的数据，内容可以发生改变，换句话说，一维数组就是一个容器。</span><br><span class="line">   数组名 - 主要指数组的名称，用于记录该连续内存空间的首地址信息。</span><br><span class="line">   数组元素 - 主要指存放在数组中的数据内容。</span><br><span class="line">   数组长度 - 主要指数组中存放的元素个数，通常使用 数组名.length来获取。</span><br><span class="line">   数组下标 - 主要指数组中元素的编号，从0开始一直到 数组名.length-1。</span><br><span class="line"></span><br><span class="line">   ##### 1.2 数组的声明</span><br><span class="line">(1)数组声明的语法格式</span><br></pre></td></tr></table></figure></p>
<p>   数据类型[] 数组名称 = new 数据类型[数组的长度]; - 动态方式<br>如：<br>   int[] arr = new int<a href="http://static.zybuluo.com/cnxielong/4ee25pl15g2b7vxdu0xtqr7s/%E8%81%9A%E5%90%88.jpg" target="_blank" rel="noopener">5</a>; - 声明一个长度为5，元素类型为int的一维数组<br>   int num = 5;            - 声明一个初始值为5的变量</p>
<p>   int arr[] = new int<a href="http://static.zybuluo.com/cnxielong/4ee25pl15g2b7vxdu0xtqr7s/%E8%81%9A%E5%90%88.jpg" target="_blank" rel="noopener">5</a>; - 不推荐使用该方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(2)注意事项</span><br><span class="line">   a.只有数组在声明的时候，[]中的数字代表数组的长度，否则一律代表下标。</span><br><span class="line">   b.当创建数组没有指定初始值时，采用默认初始化(参考ppt)。</span><br><span class="line"> </span><br><span class="line">(3)数组元素的初始化</span><br></pre></td></tr></table></figure></p>
<p>   数据类型[] 数组名称 = {初始值1,初始值2, …}; - 静态方式<br>如：<br>   int[] arr = {10, 20, 30, 40, 50}; - 声明一个长度为5元素类型为int的数组<br>   arr[0] = 10;<br>   arr<a href="http://static.zybuluo.com/cnxielong/3e7b5jotwai0qwppv171yt1q/1.jpg" target="_blank" rel="noopener">1</a> = 20;<br>   arr<a href="http://static.zybuluo.com/cnxielong/jpy3e3grlsekhx2izsysp2pm/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" target="_blank" rel="noopener">2</a> = 30;<br>   arr<a href="http://static.zybuluo.com/cnxielong/syxe3gltmycic2ukkenhgw78/%E7%BB%A7%E6%89%BF.jpg" target="_blank" rel="noopener">3</a> = 40;<br>   arr<a href="http://static.zybuluo.com/cnxielong/diat6zso4rsn6a4840dbft02/%E4%BE%9D%E8%B5%96.jpg" target="_blank" rel="noopener">4</a> = 50;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">注意：基本类型的数组（数据元素为基本类型）创建后。元素类型为：BYTE、SHORT、CHAR、INT、LONG为0；FLOAT和DOUBLE为0.0；BOOLEAN为False。</span><br><span class="line">   ##### 1.3 数组的声明 size()  length length()方法：</span><br><span class="line">1.length属性是针对Java中的数组来说的，要求数组的长度可以用其length属性；</span><br><span class="line">2.length()方法是针对字符串来说的，要求一个字符串的长度就要用到它的length()方法；</span><br><span class="line">3.java中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</span><br><span class="line"></span><br><span class="line">  #### 2.二维数组(熟悉)</span><br><span class="line">   ##### 2.1 基本概念</span><br><span class="line">   一维数组本质上就是一段连续的内存空间，用于记录多个类型相同的数据内容。</span><br><span class="line">   二维数组本质上就是由一维数组组成的数组，也就是说二维数组中的每个元素都是一个一维数组。</span><br><span class="line"></span><br><span class="line">   ##### 2.2 二维数组的声明</span><br><span class="line">(1)语法格式</span><br><span class="line">**多维数组(数组的数组)，本质上也是一维数组。**</span><br><span class="line">   数据类型[][] 数组名称 = new 数据类型[行数][列数];</span><br><span class="line">如：</span><br><span class="line">   int[][] arr = new int[2][2]; - 声明一个具有2行5列存放int类型元素的二维数组</span><br><span class="line">   其中行下标的范围是：0 ~ 1;</span><br><span class="line">   其中列下标的范围是：0 ~ 4;</span><br><span class="line"></span><br><span class="line">   arr代表什么？  arr[0]代表什么？ arr[0][0]代表什么？</span><br><span class="line">解析：</span><br><span class="line">   arr代表二维数组的名称，用于记录该二维数组的首地址。</span><br><span class="line">   arr[0]代表二维数组的第一行，也就是一个一维数组。</span><br><span class="line">   arr[0][0]代表二维数组中的第一行第一列，也就是第一个元素值。</span><br><span class="line">   int[][]a= new int a[i][j];i代表行，j代表列</span><br><span class="line">   arr.length=i;代表二维数组的长度，也就是二维数组的行数。</span><br><span class="line">   arr[0].length=j;代表第一行的列数，也就是一维数组的长度。</span><br><span class="line"></span><br><span class="line">(2)二维数组的初始化</span><br><span class="line">   数据类型[][] 数组名称 = &#123;&#123;元素值1,元素值2,...&#125;,&#123;元素值3,元素值4,...&#125;,...&#125;;</span><br><span class="line">如：</span><br><span class="line">   int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;; - 声明一个2行3列的二维数组</span><br><span class="line">   其中行下标就是：0 ~ 1；</span><br><span class="line">   其中列下标就是：0 ~ 2；</span><br><span class="line">   ##### 2.3 数组的拷贝和二维数组</span><br></pre></td></tr></table></figure></p>
<p>public class CopyArray {</p>
<pre><code>public static void main(String[] args) {
    int[] arr1 = { 2, 3, 5, 7, 11, 12 };
    System.out.println(Arrays.toString(arr1));
    // [2, 3, 5, 7, 11, 12]

    int[] cpArr = arr1;
    cpArr[5] = 99;
    // 两个变量arr1和cpArr引用同一个数组
    System.out.println(Arrays.toString(arr1));
    // [2, 3, 5, 7, 11, 99]
    System.out.println(Arrays.toString(cpArr));
    // [2, 3, 5, 7, 11, 99]

    int[] cpArr2 = Arrays.copyOf(arr1, 2 * arr1.length);
    System.out.println(Arrays.toString(cpArr2));
    // 长度过大补0 过小从前截取
    // [2, 3, 5, 7, 11, 99, 0, 0, 0, 0, 0, 0]
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">package com.study.array;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 打印</span><br><span class="line">  10 %        11 %        12 %        13 %        14 %        15 %</span><br><span class="line">10000.00    10000.00    10000.00    10000.00    10000.00    10000.00</span><br><span class="line">11000.00    11100.00    11200.00    11300.00    11400.00    11500.00</span><br><span class="line">12100.00    12321.00    12544.00    12769.00    12996.00    13225.00</span><br><span class="line">13310.00    13676.31    14049.28    14428.97    14815.44    15208.75</span><br><span class="line">14641.00    15180.70    15735.19    16304.74    16889.60    17490.06</span><br><span class="line">16105.10    16850.58    17623.42    18424.35    19254.15    20113.57</span><br><span class="line">17715.61    18704.15    19738.23    20819.52    21949.73    23130.61</span><br><span class="line">19487.17    20761.60    22106.81    23526.05    25022.69    26600.20</span><br><span class="line">21435.89    23045.38    24759.63    26584.44    28525.86    30590.23</span><br><span class="line">23579.48    25580.37    27730.79    30040.42    32519.49    35178.76</span><br><span class="line"> * @ClassName: MultidimensionalArray</span><br><span class="line"> * @Description: TODO(多维数组)</span><br><span class="line"> * @author Administrator</span><br><span class="line"> * @date 2018年5月24日 下午7:08:09</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MultidimensionalArray &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final double STARTRATE = 10;</span><br><span class="line">		final int NRATES = 6;// 汇率</span><br><span class="line">		final int NYEARS = 10;// 年份</span><br><span class="line"></span><br><span class="line">		// 数组用于存放10%...15%不同的汇率</span><br><span class="line">		double[] interestRate = new double[NRATES];</span><br><span class="line">		for (int i = 0; i &lt; interestRate.length; i++) &#123;</span><br><span class="line">			interestRate[i] = (STARTRATE + i) / 100;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 定义二维数组balances 用于存储余额</span><br><span class="line">		double[][] balances = new double[NYEARS][NRATES];</span><br><span class="line"></span><br><span class="line">		// 设置第一行余额balances[0][i]全部为10000</span><br><span class="line">		for (int i = 0; i &lt; balances[0].length; i++) &#123;</span><br><span class="line">//balances.length:10 二维数组长度 10 行数</span><br><span class="line">//balances[0].length:6 一维数组长度 6 列数</span><br><span class="line">			balances[0][i] = 10000;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 两层for循环嵌套 计算未来几年利息interest</span><br><span class="line">		for (int i = 1; i &lt; balances.length; i++) &#123;// 10 列数 从第2行开始</span><br><span class="line">			for (int j = 0; j &lt; balances[0].length; j++) &#123;// 6 行数 从第1列开始</span><br><span class="line">				// 计算上一年余额</span><br><span class="line">				double oldBalance = balances[i - 1][j];</span><br><span class="line">				// 计算税率</span><br><span class="line">				double interest = interestRate[j];</span><br><span class="line"></span><br><span class="line">				balances[i][j] = oldBalance * (1 + interest);</span><br><span class="line">				// System.out.printf(&quot;%10.2f&quot;,balances[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 打印一行利息比率</span><br><span class="line">		for (int i = 0; i &lt; interestRate.length; i++) &#123;</span><br><span class="line">			System.out.printf(&quot;%10.0f %%&quot;, 100 * interestRate[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		// 嵌套两层 for each打印余额表格</span><br><span class="line">		for (double[] ds : balances) &#123;</span><br><span class="line">			for (double d : ds) &#123;</span><br><span class="line">				System.out.printf(&quot;  %10.2f&quot;, d);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第五章-类和对象"><a href="#第五章-类和对象" class="headerlink" title="第五章  类和对象"></a>第五章  类和对象</h3><h4 id="1-对象概念"><a href="#1-对象概念" class="headerlink" title="1.对象概念"></a>1.对象概念</h4><p>1.1 什么是对象？<br>   万物皆对象。</p>
<p>1.2 什么是面向对象？<br>   面向对象就是指以特征和行为的观点去分析现实世界中事物的方式。</p>
<p>1.3 什么是面向对象编程OOP？<br>面向对象编程(Object Oriented Programming–OOP)就是指先用面向对象的观点进行分析，再采用一门面向对象的编程语言进行翻译/表达的过程。<br>   其中C语言是一门面向过程的编程语言。<br>   其中C++语言是一门既面向过程又面向对象的编程语言。<br>   其中Java语言是一门纯面向对象的编程语言。</p>
<p>1.4 为什么需要面向对象编程？<br>   面向对象编程是软件产业化发展的需求。</p>
<p>1.5 如何学好面向对象编程？<br>   深刻理解面向对象的三大特征：封装、继承、多态。</p>
<h4 id="2-类"><a href="#2-类" class="headerlink" title="2.类"></a>2.类</h4><h5 id="2-1-类的基本概念"><a href="#2-1-类的基本概念" class="headerlink" title="2.1 类的基本概念"></a>2.1 类的基本概念</h5><p>   类就是”分类”的概念，也就是对同一类事物的统称，描述该类事物共同的特征和行为<br>   类是抽象的概念，是创建对象的模板，而对象是客观存在的实体，占用一块内存空间<br>   类是一种引用数据类型，包含用于描述特征的成员变量，以及用于描述行为的成员方法（JAVA中可以忘记函数概念）。  </p>
<h3 id="2-1-1-类之间的关系"><a href="#2-1-1-类之间的关系" class="headerlink" title="### 2.1.1 类之间的关系"></a>### 2.1.1 类之间的关系</h3><p><a href="https://blog.csdn.net/u014470581/article/details/62036457" target="_blank" rel="noopener">参考链接:</a> <a href="https://blog.csdn.net/u014470581/article/details/6203645" target="_blank" rel="noopener">https://blog.csdn.net/u014470581/article/details/6203645</a><br>类之间的常见三种关系：<br><strong>继承(inheritance)：is-a</strong><br>继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。关键字extends。在UML类图设计中，继承用一条带空心三角箭头的实线表示，从子类指向父类，或者子接口指向父接口。<br><img src="http://static.zybuluo.com/cnxielong/syxe3gltmycic2ukkenhgw78/%E7%BB%A7%E6%89%BF.jpg" alt="继承.jpg-13.6kB"><br><strong>依赖(dependence)：uses-a</strong><br>一个类的方法操纵另一个类的对象。<br>代码层面，为类B作为参数被类A在某个method方法中使用。在UML类图设计中，依赖关系用由类A指向类B的带箭头虚线表示。<br><img src="http://static.zybuluo.com/cnxielong/diat6zso4rsn6a4840dbft02/%E4%BE%9D%E8%B5%96.jpg" alt="依赖.jpg-23.2kB"><br><strong>聚合(aggregation)：has-a</strong><br>一个<strong>company</strong>公司对象包含一些<strong>employee</strong>员工对象。在UML类图设计中，聚合关系以空心菱形加实线箭头表示。<br><img src="http://static.zybuluo.com/cnxielong/4ee25pl15g2b7vxdu0xtqr7s/%E8%81%9A%E5%90%88.jpg" alt="聚合.jpg-7.9kB"></p>
<h3 id="2-1-2-JAVA可变对象和不可变对象"><a href="#2-1-2-JAVA可变对象和不可变对象" class="headerlink" title="### 2.1.2 JAVA可变对象和不可变对象"></a>### 2.1.2 JAVA可变对象和不可变对象</h3><p><a href="https://blog.csdn.net/bupa900318/article/details/80696785" target="_blank" rel="noopener">参考链接:</a><a href="https://blog.csdn.net/bupa900318/article/details/80696785" target="_blank" rel="noopener">https://blog.csdn.net/bupa900318/article/details/80696785</a> </p>
<ul>
<li>不可变对象在并发程序中比较有用，由于其状态无法改变，因此无法被线程的干扰损坏或者被视为不一致状态。</li>
</ul>
<p>基本概念   </p>
<ul>
<li><p>不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，任何对它的改变都应该产生一个新的对象。</p>
</li>
<li><p>可变对象(Mutable Objects)：相对于不可变类，可变类创建实例后可以改变其成员变量值，开发中创建的大部分类都属于可变类。</p>
</li>
<li><p>不可变对象的类即为不可变类(Immutable Class)。JAVA平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等。</p>
<h5 id="2-2-类的定义"><a href="#2-2-类的定义" class="headerlink" title="2.2 类的定义"></a>2.2 类的定义</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(1)类定义的语法格式</span><br><span class="line">   class 类名&#123;</span><br><span class="line">      类体;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">类定义的一般形式如下</span><br><span class="line">[类定义修饰符] class  &lt;类名&gt;   </span><br><span class="line">&#123;   //类体</span><br><span class="line"> 	 [成员变量声明]</span><br><span class="line"> [构造函数]</span><br><span class="line">  	[成员方法]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：<br>   通常情况下，当类名由多个单词组成时，每个单词的首字母都要大写。驼峰命名法。</p>
<h5 id="2-3-成员变量-以及初始化"><a href="#2-3-成员变量-以及初始化" class="headerlink" title="2.3 成员变量 以及初始化"></a>2.3 成员变量 以及初始化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> (1)成员变量声明的语法格式</span><br><span class="line">   class 类名&#123;</span><br><span class="line">       数据类型 成员变量名 = 初始值; - 其中=初始值是可以省略的</span><br><span class="line">   &#125;</span><br><span class="line">如：</span><br><span class="line">  class Person&#123;</span><br><span class="line">      String name;    //用于描述姓名的成员变量</span><br><span class="line">      int ageNum;        //用于描述年龄的成员变量</span><br><span class="line">      double weight;  //用于描述体重的成员变量</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>  通常情况下，当成员变量名由多个单词组成时，要求从第二个单词起首字母大写。<br><img src="http://static.zybuluo.com/cnxielong/jpy3e3grlsekhx2izsysp2pm/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="成员变量初始化.jpg-124.7kB"></p>
<h5 id="2-X-补充：局部变量-成员变量区别"><a href="#2-X-补充：局部变量-成员变量区别" class="headerlink" title="2.X 补充：局部变量 成员变量区别"></a>2.X 补充：局部变量 成员变量区别</h5><ul>
<li>局部变量 - 主要指声明在方法体中的变量，作用域从声明开始一直到方法体结束。</li>
<li><p>成员变量 - 主要指声明在类体中的变量，作用域从声明开始一直到类体结束。    </p>
<ul>
<li>成员变量有两种：<br>A：一种就是类变量或静态变量  这类变量前面加static关键字修饰。<br>这类变量一旦赋值它的值就在你new出来的任何一个实例中具有相同的值<br>B：另一种叫做实例变量  前面不加static关键字修饰，每一个new出来的新实例都可以对他赋予自己需要的值</li>
</ul>
</li>
<li><p>成员变量和局部变量在内存中的分配<br>　　对于成员变量和局部变量：成员变量就是方法外部，类的内部定义的变量；局部变量就是方法或语句块内部定义的变量。局部变量必须初始化。 形式参数是局部变量，局部变量的数据存在于栈内存中。栈内存中的局部变量随着方法的消失而消失。 成员变量存储在堆中的对象里面，由垃圾回收器负责回收。   如以下代码：</p>
</li>
</ul>
<p>(2)成员变量默认初始化</p>
<h5 id="2-4-对象的创建"><a href="#2-4-对象的创建" class="headerlink" title="2.4 对象的创建"></a>2.4 对象的创建</h5><p>(1)语法格式<br>   new 类名();<br>如：<br>   new Person();  - 表示新建一个Person类型的对象，叫做匿(无)名对象; </p>
<p>(2)使用方式<br>   使用new运算创建对象的过程叫做类的实例化，也叫作构造对象，当创建对象后需要在堆区申请一块内存空间，用于记录该对象独有的成员变量信息。</p>
<h5 id="2-5-引用（引用数据类型声明的变量名）"><a href="#2-5-引用（引用数据类型声明的变量名）" class="headerlink" title="2.5 引用（引用数据类型声明的变量名）"></a>2.5 引用（引用数据类型声明的变量名）</h5><p>(1)基本概念<br>   引用：使用引用数据类型声明的变量名叫做引用变量，简称为”引用”。用于记录新建对象在堆区中的内存地址信息，便于再次访问该对象。<br>   <img src="http://static.zybuluo.com/cnxielong/eso806kiunnylxp2m4h5ujsh/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.jpg" alt="引用类型.jpg-145.2kB"></p>
<p>(2)语法格式<br>   类名 引用变量名;<br>如：<br>   Person p;<br>   Person p = new Person();   </p>
<p>注意：<br>   当需要访问成员变量时，使用 引用.成员变量名 的方式进行。<br>   p.name = “zhangfei”;<br>   p.age = 30;   </p>
<h5 id="2-6-成员方法-（格式返回值调用）"><a href="#2-6-成员方法-（格式返回值调用）" class="headerlink" title="2.6 成员方法 （格式返回值调用）"></a>2.6 成员方法 （格式返回值调用）</h5><p>2.6.1 语法格式<br>  class 类名{<br>      返回值类型 成员方法名(形参列表){<br>          方法体;<br>      }<br>  }<br>如：<br>  class Person{<br>     void show(){<br>         System.out.println(“没事出来秀一下！”);<br>     }<br>  }</p>
<p>2.6.2 成员方法的详解<br>(1)返回值类型<br>   返回值就是指从方法体内向方法体外传递的数据内容。<br>   返回值类型就是指返回值的数据类型。<br>       当返回的数据内容为66时，则返回值类型写为：int;<br>       当返回的数据内容为3.14时，则返回值类型写为：double;<br>       当返回的数据内容为”hello”时，则返回值类型写为：String;<br>   在方法体中使用return关键字返回数据并结束方法，如：return 66; return num。<br>   return关键字后面可以跟：字面值、变量、表达式以及方法的调用等。<br>   当方法体中没有可以返回的数据内容时，则返回值类型写：void即可。</p>
<p>(2)形参列表<br>   形式参数就是指从方法体外向方法体内传入的数据内容，语法格式：数据类型 形参名<br>   形参列表就是形参的集合，格式为：数据类型 变量名1,数据类型 变量名2,…<br>       当传入的数据内容为66时，则形参列表写为：int i;<br>       当传入的数据内容为3.14时，则形参列表写为：double d;<br>       当传入的数据内容为”hello”时，则形参列表写为：String s;<br>       当传入的数据内容为66和”hello”时，则形参列表写为：int i, String s;<br>   当不需要传递任何数据到方法体内时，则形参列表位置啥也不写即可。</p>
<p>(3)方法体<br>   方法体就是用于描述方法功能的语句块，通常用于多条语句的打包，从而提高代码的复用性和可维护性。</p>
<p>2.6.3 方法的调用<br>(1)语法格式<br>   引用/对象.成员方法名(实参列表);<br>如：<br>   p.show();</p>
<p>(2)使用方式<br>   实参列表主要用于进行形参列表的初始化工作，因此参数的个数、类型以及顺序等都必须与形参列表保持一致。<br>   实参可以传递字面值、变量、表达式、方法的调用等。</p>
<h5 id="2-7-构造方法"><a href="#2-7-构造方法" class="headerlink" title="2.7 构造方法"></a>2.7 构造方法</h5><p>1.1 构造方法(重中之重)<br>(1)语法格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   class 类名&#123;</span><br><span class="line">      类名(形参列表)&#123;</span><br><span class="line">         构造方法体;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">如：</span><br><span class="line">   class Person&#123;</span><br><span class="line">      Person()&#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>(2)注意事项</p>
<ul>
<li>a.构造方法的方法名称与类名完全相同。</li>
<li>b.构造方法是没有返回值类型的，连void都没有。</li>
<li>c.当new一个新对象时，会自动调用构造方法来进行该对象成员变量的初始化工作。</li>
<li>d.构造方法只能被public private等访问修饰符修饰</li>
<li>e.构造方法只能在new的时候被调用。其他情况不能用。参考下图</li>
</ul>
<p>(3)默认构造方法<br>   当一个类中没有自定义任何形式的构造方法时，编译器会自动添加一个无参的空构造方法，该构造方法叫做默认/缺省构造方法，如：Person(){}<br>   当类中出现了自定义构造方法后，则编译器不再提供任何版本的构造方法。<br>(4)构造方法重载</p>
<p>(5)建议：<br>1、建议自定义无参数构造方法，不要依赖编译器，防止出现错误。<br>2、当类中无成员变两个或者变量都为常量（final）时，建议不提供任何版本的构造。<br>3、当类中有非常量成员变量时。建议提供两个构造方法：一个无参数、一个全参数。</p>
<h5 id="2-8-方法的重载-Overload"><a href="#2-8-方法的重载-Overload" class="headerlink" title="2.8 方法的重载( Overload)"></a>2.8 方法的重载( Overload)</h5><p>(1)基本概念<br>   在同一个类中，方法名相同参数列表不同之间的方法构成重载关系。<br>原理：编译器根据参数列表不同，底层生成绑定到不同名称的方法。</p>
<p>(2)重载的主要形式<br>   方法重载的形式有：参数的个数不同、参数的类型不同以及参数的顺序不同。<br>   与参数的变量名和返回值类型无关，但建议返回值类型最好相同。</p>
<p>   判断方法能否构成重载的依据：调用该方法时能否区分即可。<br>   java.io.PrintStream类中提供了大量的重载方法，print()和println()方法。</p>
<p>(3)重载的主要作用<br>   重载的作用在于：调用者只需要记住一个方法名就可以调用不同版本的方法，从而达到不同的效果，具体调用的版本由实际参数来决定。</p>
<h4 id="3-This关键字（指针）"><a href="#3-This关键字（指针）" class="headerlink" title="3. This关键字（指针）"></a>3. This关键字（指针）</h4><h5 id="3-1调用对象参数对象"><a href="#3-1调用对象参数对象" class="headerlink" title="3.1调用对象参数对象"></a>3.1调用对象参数对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如：</span><br><span class="line">   class A&#123;&#125;</span><br><span class="line">   class B&#123;</span><br><span class="line">      void show(A a)&#123; ... &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   A a = new A();</span><br><span class="line">   B b = new B();</span><br><span class="line">   b.show(a);</span><br><span class="line">   调用对象：其中对象b是用于调用show()方法的，因此叫做调用对象。</span><br><span class="line">   参数对象：其中对象a是用于作为实参传递给show()方法的，因此叫做参数对象。</span><br></pre></td></tr></table></figure>
<h5 id="3-2-基本概念（当前对象）"><a href="#3-2-基本概念（当前对象）" class="headerlink" title="3.2 基本概念（当前对象）"></a>3.2 基本概念（当前对象）</h5><p>   对于构造方法来说，this关键字代表当前正在构造的对象。<br>   对于成员方法来说，this关键字代表当前正在调用的对象。</p>
<p>原理解析：<br>   当使用不同的对象调用同一个方法时，那么方法体中的this代表的对象也就不同，当访问成员变量时相当于使用this.的(我的)方式访问，因此最终的结果也就不同。</p>
<h5 id="3-3-使用方式（就近原则）"><a href="#3-3-使用方式（就近原则）" class="headerlink" title="3.3 使用方式（就近原则）"></a>3.3 使用方式（就近原则）</h5><p>  (1)当形参变量名和成员变量名相同时，在方法体中（就近原则）会优先选择形参变量名，若希望使用成员变量名，则需要在变量名的前面加上this.明确要求使用成员变量(掌握)。<br>  (2)使用this.的方式调用成员方法(了解)。<br>  (3)在构造方法的第一行使用this(实参)的方式调用本类中的其他构造方法(了解)。</p>
<h5 id="3-4-This构造方法"><a href="#3-4-This构造方法" class="headerlink" title="3.4 This构造方法"></a>3.4 This构造方法</h5><p>下图：this(“name”,  67, true);和this(); 只能同时出现一个。否则构造器陷入死循环编译报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.study.test;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">		</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line">	private boolean boyFriend;</span><br><span class="line">	</span><br><span class="line">	public Test() &#123;//空参构造</span><br><span class="line">//		this()和this(&quot;name&quot;,  67, true);同时只能出现一个 否则构造器陷入死循环</span><br><span class="line">		this(&quot;name&quot;,  67, true);//this 指针调用非空构造参数</span><br><span class="line">		System.out.println(&quot;I am a boy:&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Test(String name, int age, boolean boyFriend) &#123;</span><br><span class="line">//		this(); //语法报错Recursive constructor invocation Test() 地递归构造函数</span><br><span class="line">		System.out.println(&quot;I am a boy:&quot;);</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.age = age;</span><br><span class="line">		this.boyFriend = boyFriend;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-5-空指针类型异常"><a href="#3-5-空指针类型异常" class="headerlink" title="3.5 空指针类型异常"></a>3.5 空指针类型异常</h5><ul>
<li><p>原因：当引用类型变量为NULL时无法对对象实行访问，此时如果通过引用访问其变量或者调用方法，就会出现空指针异常(NullPointerException);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Calling the instance method of a null object. </span><br><span class="line">2. Accessing or modifying the field of a null object. </span><br><span class="line">3. Taking the length of null as if it were an array. </span><br><span class="line">4. Accessing or modifying the slots of null as if it were an array. </span><br><span class="line">5. Throwing null as if it were a Throwable value.</span><br></pre></td></tr></table></figure>
</li>
<li><p>1：NullPointerException由RuntimeException派生出来，是一个运行级别的异常。意思是说可能会在运行的时候才会被抛出，而且需要看这样的运行级别异常是否会导致你的业务逻辑中断。</p>
</li>
<li>2：空指针异常发生在对象为空，但是引用这个对象的方法。例如： String s = null; //对象s为空(null) int length = s.length();//发生空指针异常  </li>
<li>3：一个变量是null,及只有其名,没有实值内容,也没分配内存,当你要去取他的长度,对他进行操作就会出现NullPointException,所以声明一个变量时最好给它分配好内存空间，给予赋值。  </li>
<li>4：比如变量为空，而你没有去判断，就直接使用，就会出现NullPointException。写程序时严谨些，尽量避免了，例如在拿该变量与一个值比较时，要么先做好该异常的处理如： if (str == null) {   System.out.println(“字符为空!”); } 当然也可以将这个值写在前面进行比较的，例如，判断一个String的实例s是否等于“a”，不要写成s.equals(“a”)，这样写容易抛出NullPointerException，而写成”a”.equals(s)就可以避免这个问题。不过对变量先进行判空后再进行操作比较好  </li>
<li>5：尽量避免返回null，方法的返回值不要定义成为一般的类型，而是用数组。这样如果想要返回null的时候，就返回一个没有元素的数组。就能避免许多不必要的NullPointerException，使用NullObject返回代替返回null确是一种不错的选择。 </li>
</ul>
<h4 id="4-方法的传参和参数数目不确定"><a href="#4-方法的传参和参数数目不确定" class="headerlink" title="4. 方法的传参和参数数目不确定"></a>4. 方法的传参和参数数目不确定</h4><p>1.1 方法的传参过程(原理、尽量理解)</p>
<p>public int max(int a,int b){……}<br>int a = 5; int b = 6;<br>int res = m.max(a,b);</p>
<p>  (1)main()方法是程序的入口，为main()方法分配变量的内存空间并初始化。<br>  (2)调用max()方法，为max()方法的形参变量分配内存空间。<br>  (3)使用实际参数为形式参数进行初始化，也就是将实参的数值赋值给形参的内存空间<br>  (4)执行max()方法的方法体，执行完毕后释放形参变量的内存空间<br>  (5)main()方法得到max()方法的返回值并继续向下执行。</p>
<p>参数数目变化：<br>返回值  方法名（数据类型…  变量名)    eg:  int num(int… a)<br>其中变量名a是数组通过下标访问元素</p>
<p>public static int num(int… a) {<br>    int sum = 0;<br>    for (int i = 0; i &lt; a.length; i++) {<br>        sum += a[i];<br>    }<br>    return sum;<br>}</p>
<p>要求大家重点掌握的内容：<br>  a.当使用基本数据类型作为形参时，在方法体中改变形参变量的数值不会影响到实参;<br>  b.当使用引用数据类型作为形参时，在方法体中改变形参变量指向的数值时，则会<br>影响到实参指向的数值，因为形参和实参指向同一块区域。</p>
<p>  c.当使用引用数据类型作为形参时，在方法体中改变形参变量的指向后在更改指向的<br>内容，则不会对实参指向的内容产生影响，因为形参和实参指向不同的区域。</p>
<h4 id="5-递归和递推"><a href="#5-递归和递推" class="headerlink" title="5. 递归和递推"></a>5. 递归和递推</h4><ul>
<li>(1)基本概念<ul>
<li>递归就是指在方法体中调用该方法自身的形式。</li>
</ul>
</li>
<li>(2)使用原则<ul>
<li>a.寻找递归的规律，并指定退出条件。</li>
<li>b.递归使得问题简单化，而不是复杂化。</li>
<li>c.递归可能会影响程序的执行性能，此时需要使用递推替代之。</li>
</ul>
</li>
</ul>
<p>斐波那契数列递归：</p>
<ul>
<li>方法调用自身方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.study.test;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">	public static Long fibonacciRecursive(int i) &#123;// 递归</span><br><span class="line"></span><br><span class="line">		if (i &lt;= 2) &#123;</span><br><span class="line">			return 1L;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return fibonacciRecursive(i - 1) + fibonacciRecursive(i - 2);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public static long fibonacciRecurrence(Long i) &#123;// 递推</span><br><span class="line">		</span><br><span class="line">		if (i &lt;= 2) &#123;</span><br><span class="line">			return 1L;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			Long  s1 = 1L, s2 = 1L, sn = 0L;</span><br><span class="line">			for (int j = 2; j &lt; i; j++) &#123;</span><br><span class="line">				sn = (long)(s1 + s2);</span><br><span class="line">				s1 = s2;</span><br><span class="line">				s2 = sn;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			return sn;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		Long result = fibonacciRecursive(0);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">		Long result2 = fibonacciRecurrence(6L);</span><br><span class="line">		System.out.println(result2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>斐波那契数列递推： <ul>
<li>循环 返回值不调用函数自身</li>
</ul>
</li>
</ul>
<h3 id="第六章-封装、继承、重写、-static、-super、this、单例、构造块、静态语句块"><a href="#第六章-封装、继承、重写、-static、-super、this、单例、构造块、静态语句块" class="headerlink" title="第六章  封装、继承、重写、 static、 super、this、单例、构造块、静态语句块"></a>第六章  封装、继承、重写、 static、 super、this、单例、构造块、静态语句块</h3><h4 id="1-封装"><a href="#1-封装" class="headerlink" title="1. 封装"></a>1. 封装</h4><h5 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h5><p>   当一个类中没有做任何处理时，则测试类中可以任意访问该类中的成员，此时就有可能带来一些合法但不合理的数值，<br>   为了避免该问题的发生就需要对类中的成员进行保护处理，而这种处理方式就叫做类的封装。<br>   换句话说，封装就是一种为了保证成员变量值合理的机制。</p>
<h5 id="1-2-封装的流程"><a href="#1-2-封装的流程" class="headerlink" title="1.2 封装的流程"></a>1.2 封装的流程</h5><p>  (1)使用private关键字修饰成员变量，表示私有化。<br>  (2)提供公有的get成员变量/set成员变量方法供外界使用，在方法体中进行合理性判断<br>  (3)在构造方法体中调用set成员变量的方法进行合理性判断。<br>如下图：<br> <img src="http://static.zybuluo.com/cnxielong/4cfj55ihick99ckcwtjukh0i/image.png" alt="image.png-41.7kB"></p>
<h4 id="2-static关键字-重点"><a href="#2-static关键字-重点" class="headerlink" title="2.static关键字(重点)"></a>2.static关键字(重点)</h4><h5 id="1-1-基本概念-1"><a href="#1-1-基本概念-1" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h5><ul>
<li>通常情况下，类中的成员变量都隶属于对象层级，也就是每创建一个对象都会拥有独立的一份，当所有对象共享同一份数据时并单独记录时会导致内存空间的浪费，此时可以使用static关键字修饰该成员变量表达静态的概念，当使用static关键字修饰之后该成员变量就从对象层级提升到类层级，被所有对象共享与对象是否创建无关。<br>访问方式：推荐类名.的,不建议使用对象/引用.的方式访问。static修饰的加载到方法区</li>
</ul>
<h5 id="1-2-使用方式"><a href="#1-2-使用方式" class="headerlink" title="1.2 使用方式"></a>1.2 使用方式</h5><p>   (1)在非静态的成员方法中既可以访问非静态的成员，也可以访问静态的成员；<br>      (成员：成员变量 + 成员方法   类层级的内容被所有对象共享) 下图show()方法。<br>   (2)在静态的成员方法只能访问静态的成员，不能访问非静态的成员;下图test()方法。<br>      (成员：成员变量 + 成员方法   调用静态方法时可能还没有创建任何的对象)<br>      (静态的成员方法中是没有this关键字的)<br>   (3)只有隶属于类层级被所有对象共享的内容才能使用static关键字修饰；<br>       (不能滥用static)<br>示例代码：<br>D:\兄弟连视频\day09\code\ TestStatic.java</p>
<h4 id="3-构造块和静态语句块-熟悉"><a href="#3-构造块和静态语句块-熟悉" class="headerlink" title="3. 构造块和静态语句块(熟悉)"></a>3. 构造块和静态语句块(熟悉)</h4><p>  a. 构造块就是指在类中直接使用{}括起来的语句块；<br>  b. 静态语句块就是指在类中直接使用static{}括起来的语句块;<br>c.抽象类里面可以用构造块{}和static{}(JDK1.7语法不报错 但是没意义)<br>d.接口里面不可以用构造块和{}static{}(JDK1.7语法上报错)<br>d. static{;} 静态语句块 前面不能加任何修饰符。</p>
<p>执行流程：   静态语句块  =&gt; 构造块  =&gt; 构造方法体;</p>
<h4 id="4-单例设计模式"><a href="#4-单例设计模式" class="headerlink" title="4. 单例设计模式"></a>4. 单例设计模式</h4><p>(1)基本概念<br>   在某些特殊场合中，当一个类对外提供一个对象且只能提供一个对象时，这样的类叫做单例类，而编写单例类的设计形式和编程套路就叫做单例设计模式。实例：任务管理器只能开一个。</p>
<p>(2)实现流程<br>   a.私有化构造方法，使用private关键字修饰；<br>   b.提供本类的引用指向本类的对象，并使用private static共同修饰；<br>   c.提供公有的get成员方法负责将对象返回出去，并使用static修饰；</p>
<p>(3)实现方式<br>   单例设计模式的实现方式有两种：饿汉式 和 懒汉式，以后的开发中推荐饿汉式；<br>示例代码：<br>D:\兄弟连视频\day09\code\ Singleton.java和TestSingleton.java</p>
<h4 id="5-继承"><a href="#5-继承" class="headerlink" title="5. 继承"></a>5. 继承</h4><h5 id="5-1继承的由来和概念"><a href="#5-1继承的由来和概念" class="headerlink" title="5.1继承的由来和概念"></a>5.1继承的由来和概念</h5><p>   示例代码：<br>D:\兄弟连视频\day09\code\ Person.java和Student.java<br>当多个类中有相同的特征和行为时，就可以将相同的内容提取出来组成一个新的类，在编写这多个类时只需要继承这个新的类就可以复用相同的特征和行为，从而提高代码的复用性和可维护性。<br>   换句话说，继承就是一种实现代码复用和提高可维护性的机制。<br>   在Java语言中使用extends(子类父类继承)( 和implements(实现接口) )关键字来表达继承关系。<br>如：<br>   class Student extends Person{ … …}<br>   其中Person类叫做超类/父类/基类。<br>   其中Student类叫做派生类/子类。</p>
<h5 id="5-2-注意事项"><a href="#5-2-注意事项" class="headerlink" title="5.2 注意事项"></a>5.2 注意事项</h5><p>  (1)子类可以继承父类中的成员方法以及成员变量<br>     (私有的成员变量也可以继承但不能直接访问)<br>     子类不能继承父类的内容有：构造方法和私有成员方法。<br>父类中的构造方法是不能继承的，但是在实例化子类的时候会调用父类的构造方法。<br><a href="http://blog.csdn.net/wangyl_gain/article/details/49366505" target="_blank" rel="noopener">http://blog.csdn.net/wangyl_gain/article/details/49366505</a><br><a href="http://www.cnblogs.com/H-BolinBlog/p/5331195.html" target="_blank" rel="noopener">http://www.cnblogs.com/H-BolinBlog/p/5331195.html</a><br>  (2)无论使用何种形式构造子类的对象，都会默认调用父类的无参构造方法来构造<br>     子类对象中包含的父类对象，也就是对父类中成员变量进行初始化，相当于<br>     super()调用的效果。<br>  (3)Java语言只支持单继承不支持多继承，也就是说一个子类只能有一个父类，<br>     但一个父类可以有多个子????<br>  (4)不能滥用继承，必须满足逻辑关系：子类 is a 父类。比如：狗是动物。</p>
<h5 id="5-3-extends关键字"><a href="#5-3-extends关键字" class="headerlink" title="5.3 extends关键字"></a>5.3 extends关键字</h5><h5 id="5-4继承中的构造方法"><a href="#5-4继承中的构造方法" class="headerlink" title="5.4继承中的构造方法"></a>5.4继承中的构造方法</h5><h4 id="6-super、this关键字-熟悉"><a href="#6-super、this关键字-熟悉" class="headerlink" title="6. super、this关键字(熟悉)"></a>6. super、this关键字(熟悉)</h4><h5 id="6-1基本概念"><a href="#6-1基本概念" class="headerlink" title="6.1基本概念"></a>6.1基本概念</h5><p>   this关键字 可以代表本类的对象;<br>   super关键字 可以代表父类的对象;</p>
<h5 id="6-2使用方式"><a href="#6-2使用方式" class="headerlink" title="6.2使用方式"></a>6.2使用方式</h5><p>   使用this.的方式可以访问本类的成员变量和成员方法;<br>   使用super.的方式可以访问父类的成员变量和成员方法;</p>
<p>   使用this(实参)的方式可以调用本类中的其他构造方法;<br>   使用super(实参)的方式可以调用父类中的构造方法；</p>
<p>要求大家掌握的内容：<br>   a.使用this.的方式可以用于区分同名的成员变量和局部变量；<br>   b.使用super.的方式可以调用父类中被覆盖的方法；<br>   c.使用super(实参)的方式可以调用父类的构造方法；</p>
<h4 id="7-方法的重写-Override-重点"><a href="#7-方法的重写-Override-重点" class="headerlink" title="7.方法的重写(Override 重点)"></a>7.方法的重写(Override 重点)</h4><p> (1)基本概念<br>   当子类继承父类中的方法不足以满足子类的需求时，就可以在子类中重新写一个和父类中方法一模一样的方法，这种形式叫做方法的重写/覆盖。<br>(2)方法重写的原则（拷贝方法名称列表就行了）<br>   a.要求方法名相同、参数列表相同、返回值类型相同，从jdk1.5开始允许返回子类.<br>   b.访问权限不能变小，可以相同或变大。<br>   c.不能抛出更大的异常(异常机制)。<br>（3）Java中静态属性和方法可以被继承，不可以被重写(Override)而是被隐藏。静态方法推荐用 (类名.方法名)的方式来调用。（不推荐 对象.方法名的方式）<br>实例：</p>
<h3 id="第七章-包、访问控制符、-final、-对象创建的过程"><a href="#第七章-包、访问控制符、-final、-对象创建的过程" class="headerlink" title="第七章 包、访问控制符、 final、 对象创建的过程"></a>第七章 包、访问控制符、 final、 对象创建的过程</h3><h4 id="1-访问控制"><a href="#1-访问控制" class="headerlink" title="1. 访问控制"></a>1. 访问控制</h4><h5 id="1-1-包的定义"><a href="#1-1-包的定义" class="headerlink" title="1.1 包的定义"></a>1.1 包的定义</h5><p>   package 包名;   - 表示指定单层目录<br>   package 包名1.包名2.包名3….;  - 表示指定多层目录</p>
<pre><code>- 用于管理文件方便，更重要的是可以避免同名文件导致的错误发生。
</code></pre><p>命名格式：org.apache.(公司名称)commons(项目名).lang(模块).StringUtil(类名)</p>
<h5 id="1-2-常用的访问控制符（权限修饰符）"><a href="#1-2-常用的访问控制符（权限修饰符）" class="headerlink" title="1.2 常用的访问控制符（权限修饰符）"></a>1.2 常用的访问控制符（权限修饰符）</h5><p>   public - 表示公有的/公开的<br>   protected - 表示保护的<br>   默认访问符 - 表示默认的<br>   private - 表示私有的   </p>
<h5 id="1-3-访问控制符的权限信息"><a href="#1-3-访问控制符的权限信息" class="headerlink" title="1.3 访问控制符的权限信息"></a>1.3 访问控制符的权限信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问控制符  访问控制权限  本类   本包中的类   子类   其他类</span><br><span class="line">public        公开的     ok        ok        ok     ok</span><br><span class="line">protected     保护的     ok        ok        ok     no</span><br><span class="line">默认控制符     默认的     ok        ok        no     no</span><br><span class="line">private     	 私有的     ok        no        no     no</span><br></pre></td></tr></table></figure>
<p>要求大家掌握的内容：<br>    a.public关键字修饰的内容表示可以在任意位置访问。<br>    b.private关键字修饰的内容表示只能在本类的内部访问。<br>    c.通常情况下，成员变量都是用private修饰，成员方法都使用public修饰。<br>d. 访问控制符不能修饰static{;}静态语句块</p>
<h5 id="1-4类的修饰-修饰词顺序"><a href="#1-4类的修饰-修饰词顺序" class="headerlink" title="1.4类的修饰  修饰词顺序"></a>1.4类的修饰  修饰词顺序</h5><p>修饰词顺序：[访问权限] [abstract] [static] [final] [transient] [volatile] [synchronized] [native] [strictfp]</p>
<h4 id="2-final关键字-重点"><a href="#2-final关键字-重点" class="headerlink" title="2.final关键字(重点)"></a>2.final关键字(重点)</h4><h5 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h5><p>   final本意为“最终的，不可更改的”，修饰类、成员方法以及成员变量。</p>
<h5 id="2-2-使用方式：不能重写、不能继承、必须初始化"><a href="#2-2-使用方式：不能重写、不能继承、必须初始化" class="headerlink" title="2.2 使用方式：不能重写、不能继承、必须初始化"></a>2.2 使用方式：不能重写、不能继承、必须初始化</h5><p>   final关键字修饰类，表示该类是最终的，体现在该类不能被继承。</p>
<pre><code>- 防止滥用继承，如：java.lang.System类/String类等   
</code></pre><p>   final关键字修饰成员方法，表示该方法是最终的，体现在该方法不能被重写。</p>
<pre><code>- 防止不经意间造成的方法重写，
  如：java.text.SimpleDateFormat类中的format()方法
</code></pre><p>   final关键字修饰成员变量，表示该成员变量必须初始化而且不能更改(基本数据类型)，如果是引用name该引用不会在指向其他对象。</p>
<pre><code>- 防止不经意间造成的修改，如：java.lang.Thread类中的MAX_PRIORITY。 
</code></pre><p><strong>补充：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">   在Java语言中很少单独使用static和final关键字修饰成员变量，通常都是使用public static final共同修饰成员变量表示常量的概念。</span><br><span class="line">   通常的命名规范是：所有字母都大写，不同单词之间使用下划线连接。</span><br><span class="line">   如：</span><br><span class="line">    基本数据类型： 值不可改变    </span><br><span class="line">    public static final double PI = 3.14;</span><br><span class="line">      </span><br><span class="line"> 	 </span><br><span class="line"> 	引用：引用无法指向其他对象，对象可以更改。</span><br><span class="line"> 	final StringBuilder stringBuilder = new StringBuilder(&quot;abc&quot;);</span><br><span class="line">	System.out.println(stringBuilder.hashCode());//118352462</span><br><span class="line">	System.out.println(stringBuilder);//abc</span><br><span class="line">	stringBuilder.append(&quot;123&quot;);</span><br><span class="line">	System.out.println(stringBuilder.hashCode());//118352462</span><br><span class="line">	System.out.println(stringBuilder);//abc123</span><br><span class="line">```      </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">  #### 3.对象创建的过程</span><br><span class="line">   ##### 3.1 单个对象创建的执行过程</span><br><span class="line">示例代码：</span><br><span class="line">D:\兄弟连视频\day10\code\ TestObjectCreate.java</span><br><span class="line">   (1)在执行代码之前需要将类的字节码信息读入内存空间中的方法区，叫类的加载。</span><br><span class="line">   (2)main()方法时程序的入口，当执行new TestObjectCreate()时表示在堆区申请空间</span><br><span class="line">   (3)若成员变量没有指定初始值时，则采用默认初始化方式进行，否则采用指定的</span><br><span class="line">      初始值进行初始化。          </span><br><span class="line">   (4)执行构造块中的语句，可以对成员变量进行再次修改。</span><br><span class="line">   (5)执行构造方法体中的语句，可以对成员变量进行再次修改。</span><br><span class="line">   (6)此时对象构造完成，继续执行main()方法中的后续代码。</span><br><span class="line"></span><br><span class="line">   ##### 3.2 子类对象创建的执行过程</span><br><span class="line">示例代码：</span><br><span class="line">D:\兄弟连视频\day10\code\ TestSubObject.java  TestSuperObject.java</span><br><span class="line">  				Father.java和sun.java</span><br><span class="line">   (1)先加载父类的字节码信息，因此先执行父类的静态语句块。</span><br><span class="line">   (2)再加载子类的字节码信息，因此执行子类的静态语句块。</span><br><span class="line">   (3)执行父类的构造块，再执行父类的构造方法体，此时父类的对象构造完成。</span><br><span class="line">   (4)执行子类的构造块，再执行子类的构造方法体，此时子类的对象构造完成。</span><br><span class="line">   (5)继续执行main()方法中后续的代码。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ### 第八章 多态、接口、 内部类  Object类、包装类</span><br><span class="line">  #### 1.多态(重中之重、难点)</span><br><span class="line">   ##### 1.1 基本概念</span><br><span class="line">   多态就是指同一种事物表现出来的多种形态。</span><br><span class="line">   宠物：狗、猫、鸟、小强、...</span><br><span class="line">   整数：byte b1 = 10;  short s1 = 10; int l1 = 10; </span><br><span class="line">多态：Pet p = new Dog(); Pet p = new Cat();//Cat Dog都是Pet子类 。</span><br><span class="line">父类变量/引用指向子类对象</span><br><span class="line"> </span><br><span class="line">   ##### 1.2 语法格式</span><br><span class="line">示例代码：</span><br><span class="line">D:\兄弟连视频\day10\code\ Person.java  Student.java</span><br><span class="line">  </span><br><span class="line"> 父类类型 引用变量名 = new 子类类型();  - 父类的引用指向了子类的对象</span><br><span class="line">如：</span><br><span class="line">   Person p = new Student();</span><br><span class="line">   p.show();</span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line">   a.在编译阶段p是Person类型的，只能调用Person类中的show()方法，否则编译报错；</span><br><span class="line">   b.在运行阶段p真正指向的对象是Student类型的，最终调用Student类的show()方法；</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ##### 1.3 多态的效果</span><br><span class="line">   (1)父类的引用能直接调用父类中的成员方法。</span><br><span class="line">   (2)父类的引用不能直接调用子类中的成员方法。</span><br><span class="line">   (3)父类的引用可以直接调用父子类都有的成员方法。</span><br><span class="line">        对于非静态的成员方法来说，父类的引用最终调用子类重写以后的版本；</span><br><span class="line">        对于静态的成员方法来说，父类的引用最终调用父类自己的方法，与对象无关；</span><br><span class="line">调用静态方法：建议用    类名.静态方法</span><br><span class="line"> </span><br><span class="line">   ##### 1.4 引用数据类型之间的转换 </span><br><span class="line">   (1)当子类类型向父类类型转换时，只需要发生自动类型转换即可。</span><br><span class="line">Person ps  =  new Student(“A”,11,1001);//(小到大)自动转换</span><br><span class="line">   (2)当父类类型向子类类型转换时，需要进行强制类型转换，语法格式如下：</span><br><span class="line">        子类类型 引用变量名 = (子类类型)父类类型的引用名；</span><br><span class="line">Person ps = new Person(); 	Student s = (Student) ps;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"> (3)引用类型之间的转换必须发生在父子类之间，否则编译报错；</span><br><span class="line">Person ps = new Person();    String s1 = (String) ps;//报错</span><br><span class="line">   (4)当父类类型的引用被强制转换为子类类型时，编译阶段不会报错，但若转换的</span><br><span class="line">      子类类型并不是该引用真正指向的类型，则运行阶段产生类型转换异常。   </span><br><span class="line">类型转换异常：java.lang.ClassCastException </span><br><span class="line">   (5)为了避免上述错误的发生，建议只要进行强制类型转换则应该先使用instanceof</span><br><span class="line">      进行判断只有条件成立时再进行强制类型转换。</span><br><span class="line">   ##### 1.5 instanceof运算符 区分== equals</span><br><span class="line">语法格式如下：</span><br><span class="line">         if(父类引用 instanceof 子类类型) - 判断父类引用是否真正指向该子类类型</span><br><span class="line">        instanceof为一个操作符 可以理解为是       - 若是则返回true，否则返回false。</span><br><span class="line">实例：class Animal&#123;&#125;; class Dog extends Animal&#123;&#125;; class Cat extends Animal&#123;&#125;;</span><br><span class="line">Animal animal = new Dog();</span><br><span class="line">animal  instanceof Animal = = True; </span><br><span class="line">animal  instanceof  Dog = = True; </span><br><span class="line">animal  instanceof  Cat = = False;</span><br><span class="line"></span><br><span class="line">   ##### 补充: 区分==和equals：</span><br><span class="line"> https://www.cnblogs.com/dolphin0520/p/3592500.html</span><br><span class="line">http://blog.csdn.net/t12x3456/article/details/7341515 </span><br><span class="line">==就是用来比较值是否相等。equals方法是用来比较两个对象的引用是否相等。</span><br><span class="line">1）对于 = =运算符，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；　　　如果作用于引用类型的变量，则比较的是所指向的对象的地址。</span><br><span class="line">2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量。</span><br><span class="line">　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；　　　　</span><br><span class="line">诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</span><br><span class="line">3）对于instanceof： (class A实例) instanceof (class B)  A显式声明的类型与右边类B必须是同种类或者是B的子类才返回TRUE；</span><br><span class="line">   ##### 1.6实际应用</span><br><span class="line">示例代码：</span><br><span class="line">D:\兄弟连视频\day10\code\ Rect.java和Shape.java和Circle.java和 TestShape.java</span><br><span class="line">    使用父类的引用作为方法的形参时，可以屏蔽不同子类的差异性实现通用的编程，换句话说，就是编写一份通用的代码可以处理不同的子类对象，而且打印不同的结果。</span><br><span class="line"></span><br><span class="line">  #### 2.抽象类(重点)</span><br><span class="line">   ##### 2.1 什么是抽象方法？</span><br><span class="line">示例代码：</span><br><span class="line">D:\兄弟连视频\day10\code\ TestAbstract.java 和 SubTestAbstract.java</span><br><span class="line">   抽象方法就是指不能具体实现的方法，也就是没有方法体，并使用abstract修饰。</span><br><span class="line">   语法格式：</span><br><span class="line">       访问控制符 abstract 返回值类型 方法名称(形参列表);  </span><br><span class="line">   如：</span><br><span class="line">       public abstract void cry();</span><br><span class="line"></span><br><span class="line">   ##### 2.2 什么是抽象类？</span><br><span class="line">   抽象类就是使用abstract关键字修饰的类，抽象类是不能构造对象的。看下图</span><br><span class="line"> </span><br><span class="line">   ##### 2.3 注意事项</span><br><span class="line">   (1)抽象类中可以有成员变量、构造方法以及成员方法。</span><br><span class="line">   (2)抽象类中可以没有抽象方法，也可以有抽象方法。</span><br><span class="line">   (3)拥有抽象方法的类必须是抽象类。</span><br><span class="line">(4)抽象类中有非抽象的构造方法(构造方法 只能被public private等访问修饰)，但是无法实例化(无法new抽象类)，是为了防止生成抽象类后调用抽象方法（所以封死了构造方法）。</span><br><span class="line"></span><br><span class="line">   ##### 2.4 实际意义</span><br><span class="line">   抽象类的实际意义不在于实例化对象而在于被继承，当一个类继承抽象类就必须要重写抽象类中的抽象方法，否则该类也得声明为抽象类。</span><br><span class="line">   因此抽象类对子类具有强制性和规范性，叫做模板设计模式。</span><br><span class="line"> </span><br><span class="line">经验分享：</span><br><span class="line">   在以后的开发中推荐使用多态的语法格式在方法体中使用，因为当使用多态的语法时则调用的所有方法一定是父类中拥有的方法，若希望更换子类对象时，只需要将new后面的类型加以改变而其他代码立刻生效，因此提高了代码的可维护性和可扩展性。</span><br><span class="line">   该方式的缺点在于父类的引用不能直接访问子类的独有成员变量和成员方法。</span><br><span class="line">推荐：TestAbstract ta = new SubTestAbstract(); ta.show(); </span><br><span class="line"></span><br><span class="line">  #### 3. 接口</span><br><span class="line"></span><br><span class="line">   ##### 3.1 基本概念</span><br><span class="line"></span><br><span class="line"> - 接口就是一种比抽象类还抽象的类，该接口是不能实例化对象，更重要的是，接口中的所有方法都是抽象方法。</span><br><span class="line"> - 声明类的关键字是class，而声明接口的关键字是interface。</span><br><span class="line"> - 继承类的关键字是extends，而实现接口的关键字是implements。</span><br><span class="line"></span><br><span class="line">   ##### 3.2 注意事项</span><br><span class="line"> - (1)接口中的所有变量都必须由public static final共同修饰(可省略不报错但是极不推荐)，也就是常量。</span><br><span class="line"> - (2)接口中的所有方法由public abstract共同修饰(可以省略其中任何一个关键字也可以都省略)，也就是抽象方法。</span><br><span class="line"> - (3)JAVA SE8以后允许在接口中增加静态方法。</span><br><span class="line"> - (4)JAVA SE8以后可以为接口方法提供一个默认实现。用default修饰。</span><br></pre></td></tr></table></figure></p>
<p>public interface Path{//静态方法<br>    public static Path get(String first,String… more){<br>        return FileSystems.getDefault().getPath(first,more);<br>    }<br>}</p>
<p>public interface Comparable<t>{<br>    default int compareTo(T other){//defult默认方法<br>        return 0;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   ##### 3.3 类和接口之间的关系</span><br><span class="line"> - 类和类之间的关系     使用extends关键字表达继承的关系     支持单继承</span><br><span class="line"> - 类和接口之间的关系   使用implements关键字表达实现的关系  支持多实现</span><br><span class="line"> - 接口和接口之间的关系 使用extends关键字表达继承的关系     通常认为单继承</span><br><span class="line"></span><br><span class="line">   ##### 3.4 接口和抽象类之间的区别</span><br><span class="line"> - (1)声明抽象类的关键字是class，声明接口的关键字是interface。</span><br><span class="line"> - (2)继承抽象类的关键字是extends，实现接口的关键字是implements。</span><br><span class="line"> - (3)继承抽象类只支持单继承，而实现接口可以支持多实现。</span><br><span class="line"> - (4)抽象类中可以有构造方法，而接口中没有构造方法。</span><br><span class="line"> - (5)抽象类中可以有成员变量，而接口只允许有常量。</span><br><span class="line"> - (6)抽象类中可以有成员方法，而接口只允许有抽象方法。</span><br><span class="line"> - (7)抽象类中增加方法可以不影响子类，但接口中增加方法一定会影响子类。</span><br><span class="line"></span><br><span class="line">   ##### 3.5 接口方法冲突</span><br><span class="line"> - 前提：JAVA语法，单继承多实现。在这过程中出现多个同样的方法。</span><br><span class="line"> - 情况：一个接口中将一个方法定义为默认方法，在父类或者另一个接口中定义了同样的方法(同名，有相同的参数类型，不存在返回值类型不同的情况)。</span><br><span class="line"> - 解决方案：</span><br><span class="line">    - 1、父类优先。如果父类提供了一个具体方法，（接口中）同名而且具有相同参数类型的默认方法会被忽略。</span><br><span class="line">    - 2、接口冲突。如果一个父接口提供了一个默认方法，另一个接口提供了一个相同方法(同名参数类型相同，不论是否是默认参数)，必须覆盖这个方法来解决冲突。</span><br><span class="line">``` </span><br><span class="line">//接口冲突 对应情况2</span><br><span class="line">public interface Named &#123;</span><br><span class="line">	default String getName()&#123;//A 默认实现</span><br><span class="line">    	return getClass().getName()+&quot;:Named_&quot;+hashCode();</span><br><span class="line">	&#125;;</span><br><span class="line">//	String getName();//B 不是默认实现。不能直接用。否则报错Cannot directly invoke the abstract method getName() for the type Named</span><br><span class="line">//  A和B只能同时出现一个，否则报错Duplicate method方法重复</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">public interface Person &#123;</span><br><span class="line">	default String	getName()&#123;//另一种默认实现</span><br><span class="line">    	return getClass().getName()+&quot;:Person_&quot;+hashCode();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student implements Named, Person &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getName() &#123;//接口Person和Named 都含有同名方法getName，编译器报错，在实现类Student中选择两个冲突方法中的一个，或者自己重写方法。</span><br><span class="line">		return Person.super.getName();//Person接口的默认方法</span><br><span class="line">//		return Named.super.getName();//Named接口的默认方法</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//	public String getName() &#123;</span><br><span class="line">//		return &quot;Student&quot;;</span><br><span class="line">//	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Student student = new Student();</span><br><span class="line">		System.out.println(student.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<h4 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4.内部类"></a>4.内部类</h4><h5 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h5><ul>
<li>当把一个类的定义写在另外一个类的类体中时，那么把写在内部的类叫做内部类，该内部类所在的类叫外部类。</li>
<li><p>类中的内容主要有：成员变量、构造方法、成员方法、构造块、静态语句块、内部类。</p>
<h5 id="4-2-语法格式"><a href="#4-2-语法格式" class="headerlink" title="4.2 语法格式"></a>4.2 语法格式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 外部类名&#123;</span><br><span class="line">   class 内部类名&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-3-主要作用"><a href="#4-3-主要作用" class="headerlink" title="4.3 主要作用"></a>4.3 主要作用</h5><p>当一个类存在的价值仅仅是为某一个类单独服务时，就可以将该类定义为所服务类的内部类，内部类可以直接访问所在类的私有成员，而不再需要公有的get/set方法等。<br>内部类一般情况下对外不可见，除了包含它的外部类其他类无法访问到它。</p>
<h5 id="4-4-内部类的主要分类"><a href="#4-4-内部类的主要分类" class="headerlink" title="4.4 内部类的主要分类"></a>4.4 内部类的主要分类</h5><p>普通内部类 - 将一个类的定义直接写在另外一个类的内部(了解)。<br>静态内部类 - 使用static关键字修饰的内部类(了解)。</p>
<pre><code>- 普通的外部类是不允许使用static关键字修饰。
</code></pre><p>局部内部类 - 将一个类的定义直接写在一个方法体的内部(了解)。</p>
<pre><code>- 该类的作用域仅限于方法体的内部。
</code></pre><p>匿名内部类 - 指没有名字的内部类，用于构造父类/接口类型的对象(重点)。</p>
<h5 id="4-5-匿名内部类-重点、难点-回调模式：略"><a href="#4-5-匿名内部类-重点、难点-回调模式：略" class="headerlink" title="4.5 匿名内部类(重点、难点) 回调模式：略"></a>4.5 匿名内部类(重点、难点) 回调模式：略</h5><p>示例代码：<br>D:\兄弟连视频\day11\code\ SubA.java 和A.java和TestA.java</p>
</li>
</ul>
<p>(1)语法格式<br>   父类/接口类型 引用名 = new 父类/接口类型(){<br>       进行方法的重写<br>   };<br> (2)经验分享<br>   当使用接口类型的引用作为方法的形参时，实参的传递方式有两种：<br>a.自定义类实现接口，并创建该类的对象作为实参传递给形参。<br>b.自定义匿名内部类来构造接口的引用，使用接口引用作为实参传递给形参。</p>
<p>A是一个interface</p>
<h4 id="5-Object类-重点"><a href="#5-Object类-重点" class="headerlink" title="5. Object类(重点)"></a>5. Object类(重点)</h4><h5 id="5-1基本概念"><a href="#5-1基本概念" class="headerlink" title="5.1基本概念"></a>5.1基本概念</h5><p>java.lang.Object类是类层次结构的根类，任何类向上查找父类总是可以找到Object</p>
<h5 id="5-2-常用的包"><a href="#5-2-常用的包" class="headerlink" title="5.2 常用的包"></a>5.2 常用的包</h5><p>   java.lang包 - 该包是Java核心包，包中的所有类和接口等由JVM自动导入。</p>
<pre><code>- 如：java.lang.System/String类等
</code></pre><p>   java.util包 - 该包是Java工具包，包中提供了大量的工具类。</p>
<pre><code>- 如：java.util.Scanner/Random类等
</code></pre><p>   java.io包   - 该包是Java中的输入输出包，包中提供了大量操作文件的类等。</p>
<pre><code>- 如：java.io.FileInputStream类等。
</code></pre><p>   java.net包  - 该包是Java中网络包，包中提供了大量进行网络通信的类等。</p>
<pre><code>- 如：java.net.ServerSocket类等。
</code></pre><h5 id="5-3常用的方法"><a href="#5-3常用的方法" class="headerlink" title="5.3常用的方法"></a>5.3常用的方法</h5><p>示例代码：<br>D:\兄弟连视频\day11\code\ Student.java  TestStudent.java</p>
<p>   Object() - 使用无参形式构造对象。<br>   boolean equals(Object obj) - 用于判断调用对象是否与参数对象obj相等。</p>
<pre><code>- 该方法默认比较两个对象的地址信息是否相等，等价于 = = 的效果。
-重写equals最好要重写hashCode()方法
</code></pre><p>   int hashCode() - 用于返回调用对象的哈希码值(对象内存地址的编号)。</p>
<pre><code>- 当两个对象调用equals()方法相等时，则各自调用该方法的返回值必须相同。
- 当两个对象调用equals()方法不相等时，各自调用该方法的返回值可以相同，
  但最好不相同。
- 要求只要重新equals()方法就一定要重写hashCode()方法来保证上述约定。
</code></pre><p>   String toString() - 用于返回调用对象的字符串形式。</p>
<pre><code>- 通常该方法返回的字符串内容有：包名.类名@哈希码的十六进制。
-  System.out.println(里面内容编译器自动转换为String类型);
</code></pre><h4 id="6-包装类和数学处理类"><a href="#6-包装类和数学处理类" class="headerlink" title="6.包装类和数学处理类"></a>6.包装类和数学处理类</h4><h5 id="6-1-包装类的由来"><a href="#6-1-包装类的由来" class="headerlink" title="6.1 包装类的由来"></a>6.1 包装类的由来</h5><p>   Java语言是一门纯面向对象的编程语言，万物皆对象。<br>   Person p = new Person();<br>   int num = 10;</p>
<p>   在某些特殊场合(集合)中要求所有的数据都是对象，那么对于基本数据类型的变量来说若要使用则需要进行对象化的处理，此时就需要借助包装类将变量包装成对象。</p>
<h5 id="6-2-常用的包装类"><a href="#6-2-常用的包装类" class="headerlink" title="6.2 常用的包装类"></a>6.2 常用的包装类</h5><p>   int      =&gt;  java.lang.Integer类(重点)<br>   double   =&gt;  java.lang.Double类<br>   byte     =&gt;  java.lang.Byte类<br>   short    =&gt;  java.lang.Short类<br>   long     =&gt;  java.lang.Long类<br>   float    =&gt;  java.lang.Float类<br>   boolean  =&gt;  java.lang.Boolean类<br>   char     =&gt;  java.lang.Character类</p>
<h5 id="6-3-Integer类-重点"><a href="#6-3-Integer类-重点" class="headerlink" title="6.3 Integer类(重点)"></a>6.3 Integer类(重点)</h5><p>示例代码：<br>D:\兄弟连视频\day11\code\ TestInteger.java</p>
<p>(1)基本概念<br>   java.lang.Integer类是对int类型的包装类，该类的内部提供了int类型的成员变量。<br>   该类被final关键字。</p>
<p>(2)常用的方法<br>   该类是Object类的间接子类，并且在该类的内部重写了equals()、hashCode()、toString()方法<br>   Integer(int value) - 根据参数指定的整数值构造对象。<br>   Integer(String s) - 根据参数指定的字符串构造对象。<br>   int intValue() - 表示以int类型返回该对象的数值。<br>   static int parseInt(String s) - 用于将参数指定的字符串转换为int类型并返回。 </p>
<p>(3)装箱和拆箱<br>   从int类型向Integer类型的转换过程 叫做装箱。<br>   从Integer类型向int类型的转换过程 叫做拆箱。<br>   从jdk1.5开始提供了自动装箱和自动解箱的机制，也就是说不需要方法直接转换。</p>
<h5 id="6-4-BigDecimal类-了解"><a href="#6-4-BigDecimal类-了解" class="headerlink" title="6.4 BigDecimal类(了解)"></a>6.4 BigDecimal类(了解)</h5><p>示例代码：<br>D:\兄弟连视频\day11\code\ TestBigDecimal.java</p>
<p>(1)基本概念<br>   java.math.BigDecimal类用于实现浮点数据的精确计算。</p>
<p>(2)常用的方法<br>   BigDecimal(String val) - 根据参数指定的字符串内容来构造对象。<br>   BigDecimal add(BigDecimal augend) </p>
<pre><code>- 用于计算调用对象和参数对象的和并返回。
</code></pre><p>   BigDecimal subtract(BigDecimal subtrahend)</p>
<pre><code>- 用于计算调用对象和参数对象的差并返回。
</code></pre><p>   BigDecimal multiply(BigDecimal multiplicand) </p>
<pre><code>- 用于计算调用对象和参数对象的积并返回。
</code></pre><p>   BigDecimal divide(BigDecimal divisor) </p>
<pre><code>- 用于计算调用对象和参数对象的商并返回。
</code></pre><h5 id="6-5-BigInteger类-了解"><a href="#6-5-BigInteger类-了解" class="headerlink" title="6.5 BigInteger类(了解)"></a>6.5 BigInteger类(了解)</h5><p>示例代码：<br>D:\兄弟连视频\day11\code\ TestBigInteger.java<br>(1)基本概念<br>   java.math.BigInteger类主要用于描述long类型不足以表示的数据。</p>
<p>(2)常用的方法<br>   BigInteger(String val) - 根据参数指定的字符串来构造对象。<br>   成员方法与上述类中的方法同名。</p>
<h3 id="第九章-String类-正则表达式-StringBuilder-日期类"><a href="#第九章-String类-正则表达式-StringBuilder-日期类" class="headerlink" title="第九章 String类 正则表达式 StringBuilder 日期类"></a>第九章 String类 正则表达式 StringBuilder 日期类</h3><h4 id="1-String类"><a href="#1-String类" class="headerlink" title="1.String类"></a>1.String类</h4><p>示例代码：</p>
<h5 id="1-1-基本概念-常量池"><a href="#1-1-基本概念-常量池" class="headerlink" title="1.1 基本概念 常量池"></a>1.1 基本概念 常量池</h5><p>   java.lang.String类用于描述字符串，在Java程序中的所有字符串字面值都可以作为该类的实例描述，如：“hello”。<br>   该类描述的字符串是个常量，字符串的内容不可改变。<br>如：<br>   String      name    =   “zhangfei”;<br>     |           |              |<br>引用数据类型 引用变量名    字符串字面值</p>
<p>   name = “guanyu”; - 表示修改引用变量名name的指向，而不是指向的内容。 </p>
<p>笔试题：<br>   String str = “”; 和 String str = null;之间有区别吗？<br>解析：<br>   有区别，前面的表示有字符串对象，但里面没有内容;后面的表示连字符串对象都没有</p>
<p>常量池：<a href="http://blog.csdn.net/dajunxing/article/details/48056419" target="_blank" rel="noopener">http://blog.csdn.net/dajunxing/article/details/48056419</a><br><a href="http://www.cnblogs.com/javaminer/p/3923484.html" target="_blank" rel="noopener">http://www.cnblogs.com/javaminer/p/3923484.html</a><br><a href="http://www.cnblogs.com/SaraMoring/p/5687466.html" target="_blank" rel="noopener">http://www.cnblogs.com/SaraMoring/p/5687466.html</a> </p>
<h5 id="1-2-常用的方法"><a href="#1-2-常用的方法" class="headerlink" title="1.2 常用的方法"></a>1.2 常用的方法</h5><p>(1)常用的构造方法<br>   String() - 使用无参的方式构造对象。<br>   String(byte[] bytes) - 根据参数指定的byte数组来构造对象。<br>   String(byte[] bytes, int offset, int length) </p>
<pre><code>- 根据参数指定byte数组中从offset位置开始的length个字节来构造对象。
</code></pre><p>   String(String original) - 根据参数指定的字符串来构造对象。<br>   String(StringBuffer buffer) - 根据参数指定的引用来构造对象。<br>   String(StringBuilder builder) - 同上</p>
<p>(2)常用的成员方法<br>   char charAt(int index) - 根据参数指定的下标返回对应的字符。<br>   int length() - 用于返回字符串的长度。</p>
<p>   int compareTo(String anotherString) - 用于比较调用对象和参数对象的大小。</p>
<pre><code>- 若调用对象和参数对象相等，则返回0；若大于则返回正数；若小于返回负数
- 分别使用两个字符串中对应位置的字符从头开始进行比较，若第一个字符能够
  区分大小则比较结束，否则使用下一个位置的对应字符进行比较。
- 当字符串的前面内容相同时，则长度更大的字符串比较大。
</code></pre><p>如：<br>   “hello”  ‘h’ ‘e’ ‘l’   ‘l’ &gt; ‘h’  返回正数，证明”hello”字符串比较大<br>   “hehe”   ‘h’ ‘e’ ‘h’</p>
<p>   “hello”       ‘h’ ‘e’ …  存在的字符串内容相同时，则大小取决于长度<br>   “helloworld”  ‘h’ ‘e’ …     </p>
<p>   int compareToIgnoreCase(String str) - 比较字符串的大小，不考虑大小写。</p>
<pre><code>- 也就是相同字母的大小写之间比较的结果是相等，如：&apos;a&apos; &apos;A&apos;是相等的。
</code></pre><p>   boolean equals(Object anObject) - 比较两个字符串内容是否相等<br>   boolean equalsIgnoreCase(String anotherString) - 比较是否相等，不考虑大小写</p>
<p>   boolean contains(CharSequence s) - 判断当前字符串是否包含参数指定的内容<br>   boolean endsWith(String suffix) - 判断当前字符串是否以参数字符串为结尾<br>   boolean startsWith(String prefix) - 判断当前字符串是否以参数字符串开头<br>   String toLowerCase() - 用于将当前字符串中的所有字符转换为小写。<br>   String toUpperCase() - 用于将当前字符串中的所有字符转换为大写。<br>   String trim() - 用于去除字符串两端的空白字符。<br>   byte[] getBytes() - 用于将字符串类型转换为byte数组。<br>   char[] toCharArray() - 用于将字符串转换为char数组。</p>
<p>   int indexOf(int ch) - 返回参数指定字符在当前字符串中第一次出现的索引位置。<br>   int indexOf(int ch, int fromIndex) </p>
<pre><code>- 从fromIndex位置开始查找字符第一次出现的位置 
</code></pre><p>   int indexOf(String str) - 从当前字符串中查找str第一次出现的位置并返回。<br>   int indexOf(String str, int fromIndex) - 从fromIndex位置开始查找。</p>
<p>   int lastIndexOf(int ch) - 返回当前字符串中字符ch最后一次出现的索引位置。<br>   int lastIndexOf(int ch, int fromIndex) - 从fromIndex位置开始查找<br>   int lastIndexOf(String str) - 返回当前字符串中字符串str最后一次出现索引位置<br>   int lastIndexOf(String str, int fromIndex) - 从fromIndex位置开始查找</p>
<p>   String substring(int beginIndex) - 获取从beginIndex位置开始到结尾的子字符串<br>   String substring(int beginIndex, int endIndex) </p>
<pre><code>- 获取当前字符串中从beginIndex位置开始一直到endIndex位置(不包含)。
</code></pre><h5 id="1-3-split拆分和replace方法"><a href="#1-3-split拆分和replace方法" class="headerlink" title="1.3 split拆分和replace方法"></a>1.3 split拆分和replace方法</h5><h4 id="2-正则表达式-百度现成的"><a href="#2-正则表达式-百度现成的" class="headerlink" title="2. 正则表达式(百度现成的)"></a>2. 正则表达式(百度现成的)</h4><p>包：java.util.regex<br>(1)基本概念<br>   正则表达式本质上就是一个字符串，通常使用^开头使用$结尾，可以省略.<br>   该字符串用于进行用户输入数据的格式验证/检查，若不匹配则报错。<br>关键方法：matches     str.matches (reg) </p>
<p>(2)常用的规则  [表示一位]、{表示多位}<br>   [abc] - 表示可以出现a、b 或 c。<br>   [^abc] - 表示可以出现任何字符，除了 a、b 或 c。<br>   [a-zA-Z] - 表示可以出现a到z或A到Z，两头的字母包括在内，可以出现任何字母。</p>
<p>   . - 表示可以出现任何字符。<br>   \d - 表示可以出现任何数字，相当于[0-9]。<br>   \D - 表示可以出现任何非数字，相当于[^0-9]。<br>   \s - 表示可以出现任何空白字符，相当于[ \t\n\x0B\f\r]。<br>   \S - 表示可以出现任何非空白字符，相当于[^\s]。<br>   \w - 表示可以出现任何单词字符，相当于[a-zA-Z_0-9]，<br>        也就是由字母、数字以及下划线组成。<br>   \W - 表示可以出现任何非单词字符，相当于[^\w]。</p>
<p>   X? - 表示X可以出现一次或一次也没有，也就是0 ~ 1次。<br>   X* - 表示X可以出现零次或多次，也就是0 ~ n次。<br>   X+ - 表示X可以出现一次或多次，也就是1 ~ n次。<br>   X{n} - 表示X可以出现恰好 n 次。<br>   X{n,}- 表示X可以出现至少 n 次，也就是 &gt;= n次。<br>   X{n,m} - 表示X可以出现至少 n 次，但是不超过 m 次，也就是 &gt;= n 并且 &lt;= m次。<br>Variable must provide either dimension   expressions or an array initializer</p>
<h4 id="3-StringBuilder类和StringBuffer类-查手册会用即可"><a href="#3-StringBuilder类和StringBuffer类-查手册会用即可" class="headerlink" title="3.StringBuilder类和StringBuffer类(查手册会用即可)"></a>3.StringBuilder类和StringBuffer类(查手册会用即可)</h4><h5 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h5><p>   由于String类描述的字符序列是无法更改的，当需要描述多个相近的字符串时，不能对同一个字符串进行修改只能单独保存，因此对内存空间的消耗比较大，此时可以使用StringBuilder类和StringBuffer类来替代之，这两种类型描述的字符序列可以更改。<br>   StringBuffer类是jdk1.0就有的类，支持线程安全，因此效率比较低。<br>   StringBuilder类是jdk1.5提供的类，不支持线程安全，因此效率比较高(推荐)。</p>
<h5 id="3-2-常用的方法"><a href="#3-2-常用的方法" class="headerlink" title="3.2 常用的方法"></a>3.2 常用的方法</h5><p>   StringBuilder(String str) - 根据参数指定的内容构造对象，容量为16 + str长度<br>   int capacity() - 用于返回调用对象的容量。<br>   int length()   - 用于返回调用对象中的字符个数。</p>
<p>   StringBuilder insert(int offset, String str) </p>
<pre><code>- 用于将str插入当前字符串中下标为offset的位置。 
</code></pre><p>   StringBuilder append(String str) </p>
<pre><code>- 用于将字符串str的内容插入到当前字符串的末尾位置。
</code></pre><p>   StringBuilder delete(int start, int end)</p>
<pre><code>- 用于删除当前字符串中从start(包含)开始到end(不包含)结束。
</code></pre><p>   StringBuilder replace(int start, int end, String str) </p>
<pre><code>- 用于将当前字符串中start和end之间的字符串使用str进行替换。
</code></pre><p>   StringBuilder reverse() - 用于反转字符序列。</p>
<h4 id="4-日期相关的类-查手册会用即可"><a href="#4-日期相关的类-查手册会用即可" class="headerlink" title="4.日期相关的类(查手册会用即可)"></a>4.日期相关的类(查手册会用即可)</h4><p>示例代码：<br>D:\兄弟连视频\day12\code\ TestCalendar.java TestDate.java TestSimpleDateFormat.java</p>
<h5 id="4-1-Date类"><a href="#4-1-Date类" class="headerlink" title="4.1 Date类"></a>4.1 Date类</h5><p>(1)基本概念<br>   java.util.Date类用于描述特定的瞬间，可以精确到毫秒。</p>
<p>(2)常用的方法<br>   Date() - 使用无参的形式构造对象，默认采用当前系统时间来初始化。<br>   Date(long date) - 根据参数指定的毫秒数来构造对象。</p>
<pre><code>- 其中毫秒数为指定日期和时间距离1970年1月1日 0时0分0秒。
- 1秒 = 1000毫秒  1毫秒 = 1000微秒  1微秒 = 1000纳秒
- 该方法与File类中的一个方法是绝配。
</code></pre><p>   long getTime() - 用于获取当前对象距离1970年1月1日0时0分0秒的毫秒数。<br>   void setTime(long time) - 用于设置距离上述时间的毫秒数来更改当前对象。</p>
<h5 id="4-2-SimpleDateFormat类"><a href="#4-2-SimpleDateFormat类" class="headerlink" title="4.2 SimpleDateFormat类"></a>4.2 SimpleDateFormat类</h5><p>(1)基本概念<br>记得：import java.text.SimpleDateFormat;<br>   java.text.SimpleDateFormat类用于格式化和解析日期类型的数据。<br>   通俗来说，该类就是用于实现Date类型和String类型之间的转换。</p>
<p>(2)常用的方法<br>   SimpleDateFormat(String pattern) - 根据参数指定的格式来构造对象。</p>
<pre><code>- 其中参数字符串中的内容：y-年、M-月、d-日、H-时、m-分、s-秒
</code></pre><p>   String format(Date date) - 用于将参数指定的日期对象转换为String类型并返回。<br>   Date parse(String source) - 用于将String类型转换为日期类型并返回。</p>
<h5 id="4-3-Calendar类"><a href="#4-3-Calendar类" class="headerlink" title="4.3 Calendar类"></a>4.3 Calendar类</h5><p>(1)基本概念<br>   java.util.Calendar类用于描述特定的瞬间，该类中的方法用于取代Date类过时方法<br>   该类是一个抽象类，不能实例化对象的。</p>
<p>(2)常用的方法<br>   static Calendar getInstance() - 用于获取该类的一个实例(多态)。<br>   void set(int year, int month, int date, int hourOfDay, int minute, int second) - 用于指定年月日时分秒信息的。<br>   Date getTime() - 用于将Calendar类型的对象转换为Date类型并返回。</p>
<h5 id="4-4-TimeStamp时间戳"><a href="#4-4-TimeStamp时间戳" class="headerlink" title="4.4 TimeStamp时间戳"></a>4.4 TimeStamp时间戳</h5><h3 id="第十章-集合类（容器）Collections-Map"><a href="#第十章-集合类（容器）Collections-Map" class="headerlink" title="第十章  集合类（容器）Collections  Map"></a>第十章  集合类（容器）Collections  Map</h3><p>示例代码：</p>
<h4 id="1-综述"><a href="#1-综述" class="headerlink" title="1 .综述"></a>1 .综述</h4><h5 id="1-1-基本概念-2"><a href="#1-1-基本概念-2" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h5><p>定义：Java.util中的接口 Collection<e>又被称为Java Collections framework。Java容器的用途是保存对象，根据数据结构不同将其划分为Collection和Map。<br>   当需要记录多个类型不同/相同的数据时，则声明一个集合记录即可，集合就是容器。<br>   数组 - 本质上就是内存中的一块连续存储空间，用于记录多个类型相同的数据。</e></p>
<pre><code>- 一旦声明数组之后则长度固定，无法改变。
- 插入和删除元素不方便，可能会导致大量元素的移动。
- 支持下标访问，可以实现随机访问。
- 既可以存放基本类型的数据，也可以存放引用类型的数据。
</code></pre><p>   集合 - 内存空间可以连续也可以不连续，记录的数据类型可以相同也可以不同。</p>
<pre><code>- 集合的长度是可以随时动态调整。
- 插入和删除元素可以不移动大量的元素。
- 可以支持下标访问，随机访问。
- 只可以存放引用类型的数据，基本类型的数据不可以。    
</code></pre><h5 id="1-2-基本分类"><a href="#1-2-基本分类" class="headerlink" title="1.2 基本分类"></a>1.2 基本分类</h5><p>   在Java语言中将集合框架分为两大类：Collection接口 和 Map接口。<br>   其中Collection接口中操作元素的基本单位是：单个元素。<br>   其中Map接口中操作元素的基本单位是：单对元素。</p>
<p>   通常情况下，Collection接口很少使用，更多地使用该接口的子接口：List接口、Queue接口、以及Set接口。</p>
<h5 id="1-3-Collection接口的常用方法-熟练、记住"><a href="#1-3-Collection接口的常用方法-熟练、记住" class="headerlink" title="1.3 Collection接口的常用方法(熟练、记住)"></a>1.3 Collection接口的常用方法(熟练、记住)</h5><p>   boolean add(E e) - 用于将参数指定的元素e放入当前集合.</p>
<pre><code>- 成功返回true，否则false。
</code></pre><p>   boolean addAll(Collection&lt;? extends E&gt; c) </p>
<pre><code>- 用于将参数指定集合中的所有元素一个一个放入当前集合中。
</code></pre><p>   boolean remove(Object o) - 用于从当前集合中移除参数指定的单个元素。<br>   boolean removeAll(Collection&lt;?&gt; c) - 用于从当前集合移除参数指定所有元素。<br>   void clear() - 用于清空当前集合。</p>
<p>   boolean contains(Object o) - 用于判断是否包含单个元素。<br>   boolean containsAll(Collection&lt;?&gt; c)  - 判断是否包含参数指定所有元素</p>
<p>   boolean isEmpty() - 判断是否为空<br>   int size() - 获取元素的个数</p>
<p>   boolean retainAll(Collection&lt;?&gt; c)-计算当前集合和参数集合的交集放入当前集合<br>   Iterator<e> iterator() - 获取当前集合的迭代器。</e></p>
<h4 id="2-List接口-重中之重"><a href="#2-List接口-重中之重" class="headerlink" title="2.List接口(重中之重)"></a>2.List接口(重中之重)</h4><p>示例代码：</p>
<h5 id="2-1-基本概念-1"><a href="#2-1-基本概念-1" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h5><p>   java.util.List接口是Collection接口的子接口，元素有先后次序并且可以重复。<br>   该接口的主要实现类有：ArrayList类、LinkedList类、Stack类、Vector类。<br>   其中ArrayList类的底层是采用动态数组来进行管理的，访问方便，增删不方便。<br>   其中LinkedList类的底层是采用链表来进行管理的，访问不方便，增删方便。<br>   其中Stack类的底层是采用动态数组来进行管理的，但该类具有后进先出的特性，简称为LIFO(last in first out)，汉语名称为：栈。<br>   其中Vector类的底层是采用动态数组实现的，与ArrayList类相比是早期的类，支持线程安全，效率比较低，因此推荐使用ArrayList类。</p>
<h5 id="2-2-常用的方法-E-在此-collection-中保持的元素的类型"><a href="#2-2-常用的方法-E-在此-collection-中保持的元素的类型" class="headerlink" title="2.2 常用的方法  E - 在此 collection 中保持的元素的类型"></a>2.2 常用的方法  E - 在此 collection 中保持的元素的类型</h5><p>boolean add( E e) - 用于将指定元素添加到此列表的结尾。<br>void add(int index, E element) - 用于将元素element插入到index的位置。<br>boolean addAll(int index, Collection&lt;? extends E&gt; c) </p>
<pre><code>- 用于将集合c中的所有元素插入到当前集合中index位置。
</code></pre><p>  //  boolean add(E,e) 将集合c2看做一个整体放入集合c1中。boolean = c1.add(c2)。<br>    E remove(int index) - 用于删除当前集合中下标为index位置的元素并返回。<br>    E set(int index, E element) - 用于使用element替换下标为index位置元素并返回<br>    E get(int index) - 用于获取index位置的元素并返回。<br>public boolean retainAll(Collection&lt;?&gt; c)<br>c1.retainAll(c2) ：取c1和c2的交集并放入c1中。<br>public boolean containsAll(Collection&lt;?&gt; c)<br>c1.containsAll(c2) 如果c1包含容器c2中的所有元素，则返回 true。<br>boolean contains(Object o)<br> c1.contains(“abc”)  如果此列表中包含指定的元素，则返回 true。<br>contains调用集合包含对象的equals方法与待判断对象比较。一般要重写equals<br>    List<e> subList(int fromIndex, int toIndex) </e></p>
<pre><code>- 用于获取fromIndex位置(包含)到toIndex位置(不包含)的视图并返回。
- 只是获取数据并没有申请新的存储空间单独保存。
</code></pre><h4 id="3-泛型机制-Stack栈"><a href="#3-泛型机制-Stack栈" class="headerlink" title="3.泛型机制 Stack栈"></a>3.泛型机制 Stack栈</h4><p>示例代码：D:\兄弟连视频\day14\code\ TestStack.java<br>目前集合中之所以可以存放不同类型的数据，是因为将每个元素都看做Object类型放入的，当从集合中取出元素时默认也是Object类型，为了表达该元素真实的类型就需要强制类型转换，此方式可能引发类型转换异常。<br>   为了避免上述错误的发生，从jdk1.5开始要求使用集合时加上泛型机制，也就是在集合类型的后面使用&lt;数据类型&gt;的方式明确规定可以存放的数据内容，若放入其他类型数据则编译报错，如：<br>   List<string> l1 = new LinkedList<string>();</string></string></p>
<p>   泛型的本质就是参数化类型，也就是将数据类型作为实参传递给该接口/类中的形参E，从此E全部被替换为实参类型。<br>   jdk中的K,V,T,E等泛型名称很多人以为是固定写法，其实这些名称是可以改的，比如改成zhangsan,lisi都可以，jdk为了容易看懂，所以用K表示键，V表示值，T表示type类型，E表示enum枚举，其实这四个都只是符号，都是表示泛型名称,下面的例子的T全部可以换成E，也可以换成K,V,zhangsan，都没关系。<br>   ? 表示不确定的类型<br>   Object java中所有类的父类。<br><a href="http://blog.csdn.net/xswh520/article/details/9160875" target="_blank" rel="noopener">http://blog.csdn.net/xswh520/article/details/9160875</a></p>
<h4 id="4-Queue队列接口-重点"><a href="#4-Queue队列接口-重点" class="headerlink" title="4.Queue队列接口(重点)"></a>4.Queue队列接口(重点)</h4><p>示例代码：D:\兄弟连视频\day14\code\ TestQueue.java</p>
<h5 id="4-1-基本概念-1"><a href="#4-1-基本概念-1" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h5><p>  java.util.Queue接口是Collection接口的子接口，与List接口是平级关系。<br>  该接口的主要实现类是：LinkedList类，增删比较方便。<br>  队列就是一种具有先进先出特性的数据结构，简称为FIFO(first in first out)。</p>
<h5 id="4-2-常用的方法"><a href="#4-2-常用的方法" class="headerlink" title="4.2 常用的方法"></a>4.2 常用的方法</h5><p>  boolean offer(E e) - 用于将参数指定的元素放入当前队列的末尾。<br>  E poll() - 用于获取队列的首元素并移除，若队列为空则返回null。<br>  E peek() - 用于获取队列的首元素，若队列为空则返回null。<br>这里简单对其重复的方法做点简单的区分。<br>offer，add区别：<br>一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。<br>这时新的 offer 方法就可以起作用了。它不是对调用 add() 方法抛出一个 unchecked 异常，而只是得到由 offer() 返回的 false。 </p>
<p>poll，remove区别：<br>remove() 和 poll() 方法都是从队列中删除第一个元素。remove() 的行为与 Collection 接口的版本相似，<br>但是新的 poll() 方法在用空集合调用时不是抛出异常，只是返回 null。因此新的方法更适合容易出现异常条件的情况。</p>
<p>peek，element区别：<br>element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null</p>
<h4 id="4-Set接口-重点"><a href="#4-Set接口-重点" class="headerlink" title="4.Set接口(重点)"></a>4.Set接口(重点)</h4><p>示例代码：D:\兄弟连视频\day14\code\ TestSet.java和TestTreeSet.java</p>
<h5 id="4-1-基本概念-2"><a href="#4-1-基本概念-2" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h5><p>   java.util.Set接口是Collection接口的子接口。元素没有先后次序并且不允许重复。<br>   该接口的主要实现类：HashSet类 和 TreeSet类。<br>   其中HashSet类的底层是采用哈希表进行管理的。<br>   其中TreeSet类的底层是采用二叉树进行管理的。</p>
<h5 id="4-2-HashSet类"><a href="#4-2-HashSet类" class="headerlink" title="4.2 HashSet类"></a>4.2 HashSet类</h5><h5 id="4-3-TreeSet类"><a href="#4-3-TreeSet类" class="headerlink" title="4.3 TreeSet类"></a>4.3 TreeSet类</h5><p>常用方法：Set<integer> s1 = new TreeSet<integer>(); 一般TreeSet只存放同一种泛型的元素。方便实现Comparable接口。</integer></integer></p>
<p>(1)什么是二叉树？<br>   二叉树就是指每个节点最多只有两个子节点的树形结构。</p>
<p>(2)什么是有序二叉树？<br>   有序二叉树就是指满足以下三个条件的树形结构,又叫做二叉查找树。<br>       a.左子树中的任何节点元素值都小于根节点元素值。<br>       b.右子树中的任何节点元素值都大于根节点元素值。<br>       c.左右子树的内部也要满足上述规则。</p>
<p>(3)TreeSet类的要求<br>   当使用TreeSet类存放元素时必须要指定元素比较大小的规则，具体方式如下：<br>       a.使用元素的自然排序来指定规则，让元素类型实现java.lang.Comparable接口.<br>       b.使用比较器来指定规则，创建TreeSet对象时指定java.util.Comparator接口。</p>
<h5 id="4-4-Comparable接口和Comparator接口"><a href="#4-4-Comparable接口和Comparator接口" class="headerlink" title="4.4 Comparable接口和Comparator接口"></a>4.4 Comparable接口和Comparator接口</h5><p>Comparable接口：</p>
<p>Comparator接口</p>
<h5 id="4-5常用的工具类"><a href="#4-5常用的工具类" class="headerlink" title="4.5常用的工具类"></a>4.5常用的工具类</h5><p>   java.util.Arrays类主要提供了大量用于操作数组的工具方法。<br>   java.util.Collections类主要提供了大量用于操作集合的工具方法。</p>
<h4 id="5-Iterator迭代器常用的方法"><a href="#5-Iterator迭代器常用的方法" class="headerlink" title="5. Iterator迭代器常用的方法"></a>5. Iterator迭代器常用的方法</h4><p>   参考Collection接口即可。<br>   Iterator<e> iterator() </e></p>
<pre><code>- 用于获取当前集合中的迭代器，可以迭代/遍历/获取集合中的每个元素。 
  boolean hasNext() - 根据迭代器判断当前集合是否拥有可以访问的元素。
  E next()  - 用于获取集合中的一个元素。
  void remove() - 用于从集合中移除迭代器返回的最后一个元素。
</code></pre><p>注意：<br>   当使用迭代器访问集合中的所有元素时，切记不允许使用集合中的remove()方法删除元素，否则会引发并发修改异常，建议使用迭代器自己的remove()方法删除。</p>
<h4 id="6-增强版的for循环-for-each"><a href="#6-增强版的for循环-for-each" class="headerlink" title="6. 增强版的for循环(for each)"></a>6. 增强版的for循环(for each)</h4><p>(1)语法格式<br>   for(元素类型 变量名 : 数组名/集合名){<br>       循环体;<br>   } </p>
<p>(2)执行流程<br>   每次从数组/集合取出一个元素赋值给变量名在循环体中使用，直到取完所有元素为止 。 </p>
<p>总结：<br>   对于Set集合(无序)中的元素访问方式有3种：toString()、迭代器、for each结构。<br>   对于List集合(有序)的元素访问方式有4种：除了上述3种方式，还有get()方法。</p>
<h4 id="7-Map接口-重点"><a href="#7-Map接口-重点" class="headerlink" title="7.Map接口(重点)"></a>7.Map接口(重点)</h4><p>示例代码：D:\兄弟连视频\day15\code\ TestTreeSet.java和TestMap.java </p>
<h5 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h5><p>   java.util.Map&lt;K,V&gt;集合用于存放键值对，其中键不允许重复，只能对应一个值。<br>       类型参数：<br>          K - 此映射所维护的键(Key)的类型<br>          V - 映射值(Value)的类型<br>   该接口的主要实现类：HashMap类 和 TreeMap类。 </p>
<h5 id="7-2-常用的方法"><a href="#7-2-常用的方法" class="headerlink" title="7.2 常用的方法"></a>7.2 常用的方法</h5><pre><code>V put(K key, V value) - 用于将参数指定的key和value组成一对放入当前集合中。
    - 当该方法实现增加的功能时返回null,但实现修改的功能时则返回之前的旧值
V remove(Object key) - 用于根据参数指定的key从当前集合移除，返回对应value
boolean containsKey(Object key) - 用于判断参数指定的key是否存在。
boolean containsValue(Object value) - 用于判断参数指定的value是否存在。
V get(Object key) - 根据参数指定的key返回对应的value，若不存在则返回null。

Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() - 用于获取包含映射关系的Set视图。如下图：
     - 通俗来说，就是将Map集合转换为Set集合。
     - K getKey() - 用于获取调用对象中的key.
     - V getValue() - 用于获取调用对象中的value。
Set&lt;K&gt; keySet() - 用于获取包含键的Set视图。
</code></pre><h5 id="7-3-HashMap"><a href="#7-3-HashMap" class="headerlink" title="7.3 HashMap"></a>7.3 HashMap</h5><h3 id="第十一章-异常Exception"><a href="#第十一章-异常Exception" class="headerlink" title="第十一章 异常Exception"></a>第十一章 异常Exception</h3><p>示例代码：<br>D:\兄弟连视频\day15\code 和day16\code\ </p>
<h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><p>   异常就是不正常的意思，在Java语言中主要指在运行阶段产生的错误。<br>   Java.lang.Throwable 类是 Java 语言中所有错误或异常的超类。<br>   该类的主要实现子类有：Error类 和 Exception类。<br>   其中Error类主要用于描述比较严重的错误，无法通过编码来解决。<br>   其中Exception类主要用于描述轻微的错误，可以通过编码等方式解决。</p>
<h4 id="2-基本分类"><a href="#2-基本分类" class="headerlink" title="2. 基本分类"></a>2. 基本分类</h4><p>   Java.lang.Exception类的所有已知子类分为以下两大类：<br>        RuntimeException - 运行时异常，也叫做非检测性异常。<br>        IOException和其它所有异常 - 其它异常，也叫做检测性异常。</p>
<pre><code>- 检测性异常就是指在编译阶段可以被编译器检测出来的异常。
</code></pre><p>注意：<br>   当程序执行过程中发生异常并没有手动编码处理时，则采用默认处理方式，通常终止程序的执行并打印异常名称、异常原因以及异常的位置等信息，导致后续代码无法执行。</p>
<p>   Java.lang.RuntimeException类的主要子类：<br>       ArithmeticException - 算数异常<br>       ArrayIndexOutOfBoundsException - 数组下标越界异常(间接子类)<br>       NullPointerException - 空指针异常<br>       ClassCastException - 类型转换异常<br>       NumberFormatException - 数字格式异常(间接子类)<br>       StringIndexOutOfBoundsException - 字符串下标越界异常(间接子类)<br>       ConCurrentModificationException - 并发修改异常</p>
<h4 id="3-非检测异常的处理"><a href="#3-非检测异常的处理" class="headerlink" title="3. 非检测异常的处理"></a>3. 非检测异常的处理</h4><p>   在以后的开发中可以使用if()条件判断来避免绝大多数非检测异常的发生。</p>
<h4 id="4-异常的捕获try-catch-finally语句"><a href="#4-异常的捕获try-catch-finally语句" class="headerlink" title="4. 异常的捕获try catch finally语句"></a>4. 异常的捕获try catch finally语句</h4><p>(1)语法格式<br>   try{<br>      编写所有可能发生异常的语句块;<br>   }<br>   catch(异常类型 变量名){<br>      编写处理当前异常类型的语句块；<br>   }<br>   … …<br>   finally{<br>      编写无论是否发生异常都应该执行的语句块;<br>   }</p>
<p>(2)注意事项<br>   当需要编写多个catch()分支，切记小范围的异常类型应该放在大范围异常类型的上面。<br>   懒人的写法：<br>        catch(Exception e){ …}<br>   finally{}中通常编写用于进行善后处理的语句块，比如：关闭文件、断开数据库等。</p>
<h4 id="5-异常的抛出-throws"><a href="#5-异常的抛出-throws" class="headerlink" title="5. 异常的抛出 throws"></a>5. 异常的抛出 throws</h4><p>(1)基本概念<br>   当某些特殊场合中发生了异常却无法处理或者不便于处理时，就可以将异常抛给该方法的调用者，这个过程就叫异常的抛出/转移。可以通过throws关键字抛出异常。</p>
<p>(2)语法格式<br>   返回值类型 方法名(形参列表) throws 异常类型1,异常类型2,…{ 方法体; }<br>如：<br>   public void show() throws Exception { }      </p>
<p>(3)方法重写的原则<br>   a.要求方法名相同、参数列表相同以及返回值类型相同，从jdk1.5开始允许返回子类<br>   b.访问权限不能变小，可以相同或者变大。<br>   c.不能抛出更大的异常。</p>
<p>注意：<br>   子类中重写的方法可以抛出与父类中方法一样的异常、更小的异常以及不抛出异常，<br>但不能抛出更大的异常，也不能抛出额外的异常。</p>
<h4 id="6-自定义异常"><a href="#6-自定义异常" class="headerlink" title="6. 自定义异常"></a>6. 自定义异常</h4><p>(1)自定义异常的由来<br>   当需要在程序中表达年龄不合理的异常时，在java官方库中并没有对应的异常类型，此时就需要自定义异常类来表达该错误，从而提高代码的可读性。</p>
<p>(2)自定义异常的步骤<br>   a.自定义xxxException类继承自Exception类或者其子类。<br>   b.提供无参的构造方法和字符串作为参数的构造方法。<br>自定义构造方法：(继承父类Exception的构造方法)<br>要抛出异常的代码：</p>
<p>(3)异常对象的抛出<br>   throw new 异常类型();</p>
<h4 id="7-throws和throw区别"><a href="#7-throws和throw区别" class="headerlink" title="7. throws和throw区别"></a>7. throws和throw区别</h4><p>throws:用于抛出异常的声明。<br>格式：返回值类型 方法名(形参列表) throws 异常类型1,异常类型2,…{ 方法体; }<br>位置：throws在方法体外，在方法名(形参列表)之后。<br>后面：throws后面可以跟多个异常类型。</p>
<p>throw:用于抛出一个异常对象。<br>格式：throw new 异常类型();<br>位置：throw在方法体里面。<br>后面：throws后面只能跟一个对象。</p>
<h4 id="8-运行异常类的子类异常7个"><a href="#8-运行异常类的子类异常7个" class="headerlink" title="8. 运行异常类的子类异常7个"></a>8. 运行异常类的子类异常7个</h4><p>算术异常：ArithmeticException<br>数组下标越界异常：ArrayIndexOutOfBoundsException<br>字符串下标越界异常：StringIndexOutOfBoundsException<br>空指针异常类：NullPointerException<br>数据类型转换异常：ClassCastException<br>数据格式异常：NumberFormatException(间接子类)<br>并发修改异常： ConcurrentModificationException</p>
<h3 id="第十二章-File类-IO流"><a href="#第十二章-File类-IO流" class="headerlink" title="第十二章  File类   IO流"></a>第十二章  File类   IO流</h3><h4 id="1-File类-重点"><a href="#1-File类-重点" class="headerlink" title="1.File类(重点)"></a>1.File类(重点)</h4><p>示例代码：<br>D:\兄弟连视频day16\code\TestFile.java<br>1.1 基本概念<br>   java.io.File类用于作为文件和目录路径信息的抽象表示，可以获取文件和目录的属性信息，如：名称、大小等信息。但是不能对文件的内容进行访问。<br>1.2 常用的方法<br>  构造方法： File(String pathname) - 根据参数指定的路径名来构造对象。<br>   boolean exists() - 用于判断文件或目录是否存在。<br>   String getName() - 用于获取文件或目录的名称。<br>   long length() - 用于获取文件的长度/大小。<br>   long lastModified() - 用于获取文件的最后一次修改时间。</p>
<pre><code>- 返回距离1970年1月1日0时0分0秒之间的毫秒数
- 与Date类中的Date(long)构造方法搭配使用
</code></pre><p>   String getAbsolutePath() - 用于返回绝对路径信息。<br>       绝对路径 - 主要指从根目录开始的路径信息，如：c:/…  d:/..<br>       相对路径 - 主要指从当前目录开始的路径信息，如：./code  ./code/code<br>                  . 代表当前目录    .. 代表当前目录的上一级目录<br>       在以后的开发中推荐使用相对路径。<br>   boolean delete() - 用于删除文件或目录。<br>   boolean createNewFile() - 用于创建新的空文件。<br>   boolean mkdir() - 用于创建目录。<br>   boolean mkdirs() - 用于创建多级/层目录。<br>   File[] listFiles() - 用于获取指定目录中的所有内容并返回。<br>   boolean isFile() - 用于判断调用对象关联的是否为一个文件。<br>   boolean isDirectory() - 用于判断调用对象关联的是否为一个目录。</p>
<p>1.3 目录FileFilter接口  </p>
<h4 id="2-I-O流"><a href="#2-I-O流" class="headerlink" title="2.I/O流"></a>2.I/O流</h4><p>示例代码：<br>D:\兄弟连视频day16\code\和day17\code\<br> 2.1 基本概念<br>  I/O就是Input/Output的简写，也就是输入/输出，换句话说，也就是读取/写入操作。<br>  I/O流就是指像流水一样不间断地进行读写的操作。<br>2.2 基本分类<br>  根据读写操作的基本单位不同分为：字节流 和 字符流。<br>   其中字节流就是指以字节为基本单位进行读写的流，可以处理任何文件。<br>   字符流就是指以字符(2个字节)为基本单位进行读写的流，只能处理文本文件。</p>
<p>   根据读写操作/数据流动的方向不同分为：输入流 和 输出流(站在程序的角度)。<br>   其中输入流就是指读取文件中的内容输入到程序中的流，也就是读文件。<br>   其中输出流就是指将程序中的内容输出到文件中的流，也就是写文件。<br>数据传输方式：<br>节点流(直接和文件打交道)和包装流(程序和文件之间有管道，不直接接触)。<br>2.3 I/O流的框架<br>   字节流的顶层父类为：InputStream类 和 OutputStream类。 - 抽象类<br>   其中InputStream类的主要子类有：<br>       FileInputStream类、DataInputStream类、ObjectInputStream类。<br>   其中OutputStream类的主要子类有：<br>       FileOutputStream类、DataOutputStream类、ObjectOutputStream类。</p>
<p>   字符流的顶层父类为：Reader类 和 Writer类。           - 抽象类<br>   其中Reader类的主要子类有：<br>      BufferedReader类、InputStreamReader类、StringReader类。<br>   其中Writer类的主要子类有：<br>      BufferedWriter类、OutputStreamWriter类、StringWriter类。</p>
<p>补充：<br>   PrintStream类是OutputStream类的间接子类。<br>2.4 FileOutputStream类(重中之重)<br>(1)基本概念<br>   java.io.FileOutputStream类用于将图像数据之类的原始字节流写入到输出流中。</p>
<p>(2)常用的方法<br>   FileOutputStream(String name) - 根据参数指定的文件路径构造对象并建立关联。<br>   FileOutputStream(String name, boolean append) - 以追加的方式建立关联。<br>   void write(int b) - 用于写入参数指定的单个字节。b自动找对应的ASCII码值。<br>   void write(byte[] b, int off, int len) </p>
<pre><code>- 用于将数组b中从off位置开始的len个字节写入。
</code></pre><p>   void write(byte[] b) - 用于将参数指定整个数组的内容写入。<br>   void close() - 关闭输出流并释放有关的资源。</p>
<p>2.5 FileInputStream类(重中之重) -1和1<br>(1)基本概念<br>   java.io.FileInputStream类主要用于读取图像数据之类的原始字节流。   </p>
<p>(2)常用的方法<br>   FileInputStream(String name) - 根据参数指定的路径名来构造对象。<br>   int read() - 用于从输入流中读取一个字节并返回。</p>
<pre><code>- 当读取到文件末尾时则返回-1，否则返回读取到的数据内容。
</code></pre><p>   int read(byte[] b, int off, int len) </p>
<pre><code>- 从输入流中读取len个字节的数据放入数组b中下标为off的位置上。
- 当读取到文件末尾时则返回-1，否则返回读取到的字节个数。
</code></pre><p>   int read(byte[] b) </p>
<pre><code>- 用于从输入流中读取b.length个字节到数组b中。
</code></pre><p>   int available() </p>
<pre><code>- 用于返回通过此输入流可以读取到的文件大小。
</code></pre><p>   void close()- 关闭输出流并释放有关的资源。</p>
<p>注意：<br>文件调用 FileOutputStream.write(-1);-1默认是INT型4个字节（32位，32个1）。但是void write(int b)方法只能写入一个字节（8位），所以读取的是低8位，即：1111 1111。<br>文件调用FileInputStream.read();但是int read( )方法只能读取一个字节（8位），但是返回一个int型4个字节，32位。所以前面补32-8=24个0。即：0000 0000 0000 0000 0000 0000 1111 1111。所以返回255。</p>
<p>文件拷贝：FIS FOS<br>2.6 DataOutputStream类(熟悉)<br>(1)基本概念<br>   java.io.DataOutputStream类用于将基本类型的数据写入输出流中。</p>
<p>(2)常用的方法<br>   DataOutputStream(OutputStream out) - 根据参数指定的引用来构造对象。</p>
<pre><code>- 其中OutputStream类是抽象类，实参需要传递子类的对象。
</code></pre><p>   void writeInt(int v) - 用于将参数指定的整型变量值写入输出流中。<br>   void close()</p>
<p>2.7 DataInputStream类(熟悉)<br>(1)基本概念<br>   java.io.DataInputStream类用于从输入流中读取基本类型的数据。</p>
<p>(2)常用的方法<br>   DataInputStream(InputStream in) - 根据参数指定的引用来构造对象。</p>
<pre><code>- 其中InputStream类是抽象类，实参需要传递子类的对象。
</code></pre><p>   int readInt() - 用于从输入流中读取一个整型数据并返回。<br>   void close()- 用于关闭IO流<br>2.8 BufferedReader类(重点)<br>(1)基本概念<br>   java.io.BufferedReader类用于读取单个字符、字符数组以及一行字符内容。   </p>
<p>(2)常用的方法<br>   BufferedReader(Reader in) - 根据参数指定的引用来构造对象。</p>
<pre><code>- 其中Reader类是个抽象类，实参需要传递子类的对象。
- 子类对象选择InputStreamReader类型的对象，选择FileInputStream类型对象
</code></pre><p>   String readLine() - 用于读取一行字符串内容并返回。<br>   void close()          - 用于关闭IO流</p>
<p>2.9 BufferedWriter类(重点)<br>(1)基本概念<br>   java.io.BufferedWriter类用于写入单个字符、字符数组以及一行字符内容。    </p>
<p>(2)常用的方法<br>   BufferedWriter(Writer out) - 根据参数指定的引用来构造对象。</p>
<pre><code>- 其中Writer类是个抽象类，实参需要传递子类的对象。
- 子类对象选择OutputStreamWriter类的对象，选择FileOutputStream类型对象
</code></pre><p>   void write(String s, int off, int len) </p>
<pre><code>- 用于将字符串s中从下标为off位置开始的len个字符写入输出流中。
</code></pre><p>   void newLine() - 用于写入行分隔符。<br>   void close()       - 关闭该流的缓冲。<br>   void write(String str) - 从Writer类继承下来的方法，用于写入参数指定的字符串<br>void flush()        - 刷新该流的缓冲。对于输出的缓冲流，写出的数据会先在内存中缓存，使用flush()将会使内存中的数据立刻写出 </p>
<p>2.10 PrintStream类(重点)<br>(1)基本概念<br>   java.io.PrintStream类用于方便地打印各种格式的数据。</p>
<p>(2)常用的方法<br>   PrintStream(OutputStream out) - 根据参数指定的引用构造对象。</p>
<pre><code>- 其中OutputStream类是抽象类，实参需要传递子类的对象。
</code></pre><p>   void print(String s) - 用于打印参数指定的字符串。<br>   void println(String x) - 用于打印字符串并终止该行。<br>void write(byte[] buf, int off, int len) </p>
<pre><code>- 将 len 字节从指定的初始偏移量为 off 的 byte 数组写入此流。
</code></pre><p>   void close()<br>(3)PrintStream与BufferedReader相对应。 </p>
<p>2.11 ObjectOutputStream类(重点)<br>(1)基本概念<br>   java.io.ObjectOutputStream类用于将Java语言的对象整体写入到输出流中。<br>   只能将支持 java.io.Serializable 接口的对象写入流中。(类必须实现该接口)<br>   类通过实现 java.io.Serializable 接口以启用其序列化功能。<br>   所谓的序列化就是指将对象中需要保存的相关信息有效地组织成字节序列的过程。</p>
<p>(2)常用的方法<br>   ObjectOutputStream(OutputStream out) - 根据参数指定的引用来构造对象。</p>
<pre><code>- 其中OutputStream类是抽象类，因此实参需要传递子类的对象。
</code></pre><p>   void writeObject(Object obj) - 用于将参数指定的对象写入到输出流中。<br>   void close()<br>User是一个类且已经实现java.io.Serializable 接口<br>2.12 ObjectInputStream类(重点)<br>(1)基本概念<br>   java.io.ObjectInputStream类用于从输入流中读取整个对象。</p>
<p>(2)常用的方法<br>   ObjectInputStream(InputStream in) - 根据参数指定的引用构造对象。</p>
<pre><code>- 其中InputStream类是抽象类，因此实参需要传递子类的对象。
</code></pre><p>   Object readObject() - 用于读取一个对象并返回。</p>
<pre><code>- 无法通过该方法的返回值来判断是否读取到文件末尾。
</code></pre><p>   void close()</p>
<p>经验：<br>   当需要向文件中写入多个对象时，建议先将多个对象放入集合中，再将整个集合看做一个对象整体写入文件中，此时读取文件中的内容只需要读取一次就结束。</p>
<p>2.13 转换类InputStreamReader和OutputStreamReader<br>(1)基本概念<br>   java.io. InputStreamReader：输入时，实现字节流到字符流的转换，提高操作的效率（前提是，数据是文本数据）。= = = =》解码：字节数组—-&gt;字符串<br>   java.io. InputStreamReader：输出时，实现字符流到字节流的转换，提高操作的效率（前提是，数据是文本数据）。= = = =》解码：字符串 —-&gt;字节数组</p>
<p>2.14 标准的输入输出流<br>System.in:标准输入流（键盘输入）      System.out:标准输出流（显示器输出）</p>
<h3 id="第十三章-线程"><a href="#第十三章-线程" class="headerlink" title="第十三章  线程"></a>第十三章  线程</h3><p>示例代码：</p>
<h4 id="1-线程的基本概念和基本操作"><a href="#1-线程的基本概念和基本操作" class="headerlink" title="1.线程的基本概念和基本操作"></a>1.线程的基本概念和基本操作</h4><h5 id="1-1-线程、进程-基本概念"><a href="#1-1-线程、进程-基本概念" class="headerlink" title="1.1 线程、进程 基本概念"></a>1.1 线程、进程 基本概念</h5><p>最主要的区别：每个进程拥有自己的一整套变量，而线程(轻量级)则共享数据。</p>
<ul>
<li>程序 - 数据结构 + 算法，主要指存放在硬盘/磁盘上的可执行文件。</li>
<li>进程 - 主要指运行在内存中的程序。</li>
<li>目前主流的操作系统都支持多进程，为了让操作系统在同一时间可以执行多个任务，但进程是重量级的，新建进程对系统的资源消耗比较大，因此不建议启动过多的进程。</li>
<li>线程就是指进程内部的程序流，也就是说操作系统支持多进程，在每一个进程的内部又可以支持多线程，并且线程是轻量级的，新建线程会共享所在进程的资源。</li>
<li>因此在以后的开发中都使用多线程的机制。</li>
<li><p>操作系统中通常都采用时间片轮转法来保证多个任务的并发执行，所谓的并发就是指宏观并行，微观串行。</p>
<h5 id="1-2-Thread类"><a href="#1-2-Thread类" class="headerlink" title="1.2 Thread类"></a>1.2 Thread类</h5></li>
<li><p>简介：</p>
<ul>
<li>Thread类代表线程类型。</li>
<li>所有线程对象都是Thread类(子类)的对象实例。</li>
<li>Thead是线程的模板，封装了线程相关操作和属性。</li>
<li>继承Thread要重新run（）方法。</li>
<li>Thread.start()方法启动线程，启动后会并发的执行run()方法。</li>
</ul>
<h4 id="2-线程的创建和主要方法"><a href="#2-线程的创建和主要方法" class="headerlink" title="2.线程的创建和主要方法"></a>2.线程的创建和主要方法</h4><h5 id="2-1-线程的创建-重中之重"><a href="#2-1-线程的创建-重中之重" class="headerlink" title="2.1 线程的创建(重中之重)"></a>2.1 线程的创建(重中之重)</h5><p>(1)线程的创建方式</p>
</li>
<li><p>java.lang.Thread类用于描述线程，Java 虚拟机允许应用程序并发地运行多个执行线程。</p>
</li>
<li>创建线程的主要方式：<ul>
<li>a.自定义类继承Thread类并重写run()方法，创建该类的对象调用start()方法。</li>
<li>b.自定义类实现Runnable接口并重写run()方法，创建该类的对象作为创建Thread类对象的实参，最后使用Thread类的对象调用start()方法。</li>
</ul>
</li>
</ul>
<p>(2)线程创建的相关方法</p>
<ul>
<li>Thread() - 使用无参的方式构造对象。</li>
<li>Thread(String name) - 使用参数指定的名称来构造对象。</li>
<li>Thread(Runnable target) - 根据接口类型的引用来构造对象。</li>
<li>Thread(Runnable target, String name) - 根据接口引用和名称来共同构造对象。</li>
<li>void run() - 当调用对象是根据参数指定的接口引用构造时，则最终调用该接口引用所指向对象的run()方法，否则该方法啥也不做并返回。</li>
<li>void start() - 用于启动线程，JVM会调用该线程的run()方法。 </li>
</ul>
<p>(3)多线程的原理分析</p>
<ul>
<li>其中执行main()方法的线程叫做主线程，执行run()方法的线程叫做新线程/子线程。</li>
<li>对于start()方法之前的代码来说，只会被主线程执行一次，当start()方法调用成功之后，线程的个数瞬间由1个变成了2个，其中新创建的子线程去执行run()方法中的代码块，而主线程继续向下执行，于是两个线程同时执行产生了交错的打印结果。</li>
<li>当run()方法的代码执行完毕后表示子线程结束；当main()方法的代码执行完毕后表示主线程结束，各自独立运行互不影响；主线程和子线程的先后执行次序没有明确的规定，由系统的调度算法来决定。</li>
</ul>
<p>注意：</p>
<ul>
<li>线程创建和启动的两种方式相比，采用继承的方式相对来说代码量简单但是可维护性比较差，而实现接口的方式代码相对复杂但可维护性更高，因此推荐使用实现接口的方式。<br>继承方式：</li>
</ul>
<p>实现接口方式： </p>
<h5 id="2-2-线程的名称和编号"><a href="#2-2-线程的名称和编号" class="headerlink" title="2.2 线程的名称和编号"></a>2.2 线程的名称和编号</h5><ul>
<li>long getId() - 用于获取线程的编号/标识符并返回。</li>
<li>String getName() - 用于获取线程的名称并返回。</li>
<li>void setName(String name) - 用于修改线程的名称为参数指定的内容。</li>
<li><p>static Thread currentThread() - 用于返回当前正在执行的线程对象的引用。</p>
<h5 id="2-3-线程的主要状态"><a href="#2-3-线程的主要状态" class="headerlink" title="2.3 线程的主要状态"></a>2.3 线程的主要状态</h5><p>参考资料:<a href="https://blog.csdn.net/houbin0912/article/details/77969563" target="_blank" rel="noopener">https://blog.csdn.net/houbin0912/article/details/77969563</a><br><img src="http://static.zybuluo.com/cnxielong/sbitm3y75sgw7ozjbycp4bgl/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="线程状态.png-98.6kB"></p>
</li>
<li><p>New(新建状态) </p>
<ul>
<li>当使用new创建线程对象之后进入的状态。Thread t = new MyThread();</li>
<li>此时线程并没有开始执行。</li>
</ul>
</li>
<li>Runnable(就绪状态) <ul>
<li>调用start()方法之后进入的状态。</li>
<li>此时线程依然没有开始执行。</li>
<li>就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</li>
</ul>
</li>
<li>Running(运行状态）<ul>
<li>当线程调度器调用已经就绪完成的线程后进入的状态。</li>
<li>此时线程开始执行。</li>
<li>当时间片执行完毕后但任务没有完成时回到就绪状态。</li>
</ul>
</li>
<li><p>Blocked(阻塞状态)</p>
<ul>
<li>当线程在执行的过程中发生了阻塞事件进入的状态，如：sleep()方法。</li>
<li>当阻塞解除后进入就绪状态。</li>
<li>根据阻塞产生的原因不同，阻塞状态又可以分为三种：<ul>
<li>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</li>
<li>2.同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</li>
<li>3.其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ul>
</li>
</ul>
</li>
<li><p>Terminated(消亡状态/被终止)</p>
<ul>
<li>当时间片执行完毕后并且任务已经完成时进入的状态。或者因异常退出了run()方法，该线程结束生命周期。</li>
<li>此时线程已经终止。</li>
</ul>
</li>
<li><p>Waiting(等待状态)</p>
<ul>
<li>也有六种状态的分法，我不记了，怕混淆。 </li>
</ul>
<h5 id="2-4-Thread类的常用方法"><a href="#2-4-Thread类的常用方法" class="headerlink" title="2.4 Thread类的常用方法"></a>2.4 Thread类的常用方法</h5></li>
<li>static void yield() - 让出CPU的执行权，转而去执行其他的线程(了解)。</li>
<li>static void sleep(long millis) - 让当前正在执行的线程休眠参数指定的毫秒数。</li>
<li>static void sleep(long millis, int nanos) - 让线程休眠参数指定的毫秒 + 纳秒。<ul>
<li>1秒 = 1000毫秒  1毫秒 = 1000微秒  1微秒 = 1000纳秒</li>
</ul>
</li>
<li>void interrupt() - 用于中断线程，通常用于睡眠的打断(了解)。 </li>
<li>int getPriority() - 用于获取当前线程的优先级。</li>
<li>void setPriority(int newPriority) - 用于修改线程的优先级为参数指定的数值。<ul>
<li>优先级高的线程表示获取时间片的机会越多，但不保证一定先执行。</li>
</ul>
</li>
<li>boolean isDaemon() - 用于判断当前线程是否为守护线程。</li>
<li>void setDaemon(boolean on) - 用于设置该线程为守护线程。</li>
<li><p>void join() - 用于等待调用对象所描述的线程终止。</p>
<ul>
<li>void join(long millis) - 等待调用对象终止的最长时间为参数指定的毫秒。</li>
<li>void join(long millis, int nanos) - 用于等待参数指定的毫秒 + 纳秒。</li>
<li>守护线程又叫做后台线程，当所有非守护线程结束时，守护线程随之结束。</li>
</ul>
<h4 id="3-线程的同步机制-重点"><a href="#3-线程的同步机制-重点" class="headerlink" title="3.线程的同步机制(重点)"></a>3.线程的同步机制(重点)</h4><h5 id="3-1-基本概念-1"><a href="#3-1-基本概念-1" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h5></li>
<li>当多个线程在同一时刻访问同一种共享资源时，可能会造成数据的不一致问题，此时就需要对线程的操作进行协调，而线程之间的协调和通信就叫做线程的同步机制。  </li>
<li><p>竞争条件:（race condition）当两个或以上的线程对同一个数据进行操作的时候，此时对该数据的操作是非“原子化”的，可能前一个线程对数据的操作还没有结束，后一个线程又开始对同样的数据开始进行操作，这就可能会造成数据结果的变化未知。</p>
<h5 id="3-2-解决方案"><a href="#3-2-解决方案" class="headerlink" title="3.2 解决方案"></a>3.2 解决方案</h5><p>由程序可知：当线程一还没有来得及将最新余额写入后台数据库时，线程二已经开始执行， 导致最终的结果不正确。<br>解决方案：  将多个线程的并行操作改为串行操作即可。<br>引发问题：  当多个线程依次串行执行时，会导致执行的效率比较低，因此能不用则不用。</p>
<h5 id="3-3-实现方式"><a href="#3-3-实现方式" class="headerlink" title="3.3 实现方式"></a>3.3 实现方式</h5><p>为了解决上述问题，可以使用Java语言中synchronized关键字来保证线程操作的原子性，也就是说当线程执行锁定的代码时必须执行完毕才会释放CPU的执行权。<br>具体方式如下：<br>   (1)使用同步语句块的方式来保证原子性，语法格式如下：</p>
<pre><code>synchronized(类类型的引用){//可以用synchronized(this)
    编写需要锁定的代码块;
}
注意：
   多个线程所使用的锁对象必须是同一个对象，否则无法实现同步的效果。
   因此通常推荐使用this关键字。
</code></pre><p>  (2)使用synchronized关键字来修饰整个方法。 </p>
<h5 id="3-4-原理分析"><a href="#3-4-原理分析" class="headerlink" title="3.4 原理分析"></a>3.4 原理分析</h5><p>当多个线程启动后各自独立运行都去抢占对象锁，若其中一个线程抢到了对象锁则可以放心地执行锁定的所有代码，其他线程进入阻塞状态，直到该线程执行完毕所有锁定代码后自动释放对象锁，此时等待的其他线程又可以抢占对象锁，抢到的线程去执行锁定的代码，抢占不到的线程继续保持阻塞状态。</p>
<h5 id="3-5-死锁的概念"><a href="#3-5-死锁的概念" class="headerlink" title="3.5 死锁的概念"></a>3.5 死锁的概念</h5><p>线程一执行的代码：<br>void run(){</p>
<pre><code>synchronized(a){      持有对象锁a，等待对象锁b
   ...
   synchronized(b){
       ... ...
   }
}
</code></pre><p>}<br>线程二执行的代码：<br>void run(){</p>
<pre><code>synchronized(b){     持有对象锁b，等待对象锁a
   ...
   synchronized(a){
       ... ...
   }
}
</code></pre><p>}<br>在以后的开发中尽量不要使用同步语句块的嵌套结构！！！</p>
<h5 id="3-6-Object类中的常用方法"><a href="#3-6-Object类中的常用方法" class="headerlink" title="3.6 Object类中的常用方法"></a>3.6 Object类中的常用方法</h5><p>void wait() - 用于让当前正在执行的线程进入阻塞状态，直到其他线程调用notify()或者notifyAll()方法(开发中推荐)。<br>void wait(long timeout) - 用于让当前线程进入阻塞状态，直到其他线程调用方法或者参数指定的毫秒数已经过去了。<br>void notify() - 用于唤醒等待的单个线程(随机)。<br>void notifyAll() - 用于唤醒等待的所有线程。</p>
<h5 id="3-7-线程池"><a href="#3-7-线程池" class="headerlink" title="3.7 线程池"></a>3.7 线程池</h5><h4 id="4-线程的属性"><a href="#4-线程的属性" class="headerlink" title="4.线程的属性"></a>4.线程的属性</h4><h5 id="4-1-Priority优先级"><a href="#4-1-Priority优先级" class="headerlink" title="4.1 Priority优先级"></a>4.1 Priority优先级</h5></li>
<li>每个线程都有一个优先级。默认继承它的父类的优先级。</li>
<li>取值范围:1-10,MIN_PRIORITY=1,MAX_PRIORITY=10,NORM_PRIORITY=5。</li>
<li>优先级高度依赖于系统，JVM依赖宿主机平台的线程机制。windows 7各等级，Oracle为Linux提供的JVM，所有线程优先级相同。</li>
<li><p>void setPriority(int )优先级越高，获得运行的机会越大。</p>
<h5 id="4-2-Daemon-Thread守护线程"><a href="#4-2-Daemon-Thread守护线程" class="headerlink" title="4.2 Daemon Thread守护线程"></a>4.2 Daemon Thread守护线程</h5></li>
<li>守护线程唯一作用为其它线程提供服务，比如计时线程。</li>
<li><p>void setDaemon(boolean isDammon)，此方法必须在线程启动之前调用。</p>
<h3 id="第十四章-网络编程"><a href="#第十四章-网络编程" class="headerlink" title="第十四章 网络编程"></a>第十四章 网络编程</h3><p>示例代码：</p>
<h4 id="1-网络编程的常识-记住"><a href="#1-网络编程的常识-记住" class="headerlink" title="1.网络编程的常识(记住)"></a>1.网络编程的常识(记住)</h4><h5 id="1-1-七层网络协议模型"><a href="#1-1-七层网络协议模型" class="headerlink" title="1.1 七层网络协议模型"></a>1.1 七层网络协议模型</h5><p>ISO(国际标准委员会组织)将数据的传递从逻辑上划分为了以下七层：</p>
<pre><code>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。
</code></pre><p>当发送数据时需要按照上述七层的先后次序一层层进行加包处理，然后再发出。<br>当接收到数据时需要按照上述七层的相反次序一层层进行拆包处理，然后再解析。</p>
<h5 id="1-2-常见的网络协议"><a href="#1-2-常见的网络协议" class="headerlink" title="1.2 常见的网络协议"></a>1.2 常见的网络协议</h5><p>http - 超文本传输协议，浏览网页时可以使用该协议。<br>ftp  - 文件传输协议，  上传和下载文件时使用该协议。<br>tcp  - 传输控制协议，  进行网络通信时使用该协议。<br>udp  - 用户数据报协议，进行网络通信时使用该协议。视频缓存。<br>ip   - Internet Protocol互联网协议，是上述协议的底层协议。</p>
<p>协议 - 本质上就是一种约定/规则，用于实现双方有效的通信。</p>
<h5 id="1-3-IP地址-重点"><a href="#1-3-IP地址-重点" class="headerlink" title="1.3 IP地址(重点)"></a>1.3 IP地址(重点)</h5><p>如：<br>192.168.1.1  - 绝大多数路由器的登录地址，进行Mac地址过滤。  </p>
<p>IP地址 - 是互联网中的唯一标识，可以通过IP地址定位到具体某一台主机。<br>IP地址本质上是由32位二进制组成的整数，叫做ipv4，当然也有128位二进制组成的整数，叫做ipv6，目前使用主流的还是ipv4.<br>日常生活中采用点分十进制表示法来进行IP地址的描述，也就是将IP地址的每个字节转换为一个十进制整数，不同的十进制整数之间采用小数点分隔。<br>如：</p>
<pre><code>0x01 02 03 04 =&gt; 1.2.3.4
</code></pre></li>
</ul>
<p>查看IP地址：<br>   在windows系统的dos窗口中使用命令： ipconfig   ipconfig/all<br>   在linux系统的终端窗口中使用命令：  ifconfig   /sbin/ifconfig<br>1.4 端口号(重点)<br>   IP地址 - 可以定位到具体某一台设备/主机。<br>   端口号 - 可以定位某台设备/主机中的具体某个进程。<br>   网络通信/编程提供：IP地址 + 端口号。</p>
<p>   端口号本质上就是由16位二进制组成的整数，范围是：0 ~ 65535，其中0 ~ 1024之间的端口号通常被系统占用，因此编程时需要从1025开始使用。</p>
<h4 id="2-基于tcp协议的编程模型-重点"><a href="#2-基于tcp协议的编程模型-重点" class="headerlink" title="2. 基于tcp协议的编程模型(重点)"></a>2. 基于tcp协议的编程模型(重点)</h4><h5 id="2-1-基本概念-2"><a href="#2-1-基本概念-2" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h5><p>   C/S架构 - C(Client 客户端)/S(Server 服务器)<br>   B/S结构 - B(Browser 浏览器)/S(Server 服务器)<br>   Socket - 本意”插座”，在网络编程中表示用于通信的逻辑载体/端点，俗称“套接字”。</p>
<h5 id="2-2-编程模型"><a href="#2-2-编程模型" class="headerlink" title="2.2 编程模型"></a>2.2 编程模型</h5><p>服务器：<br>   (1)创建ServerSocket类型的对象，并绑定参数指定的端口号。<br>   (2)等待客户端的连接请求，调用accept()方法。<br>   (3)得到Socket类型的对象并使用输入输出流进行通信。<br>   (4)关闭Socket并释放有关的资源。</p>
<p>客户端：<br>   (1)创建Socket类型的对象，并提供服务器的IP地址和端口号。<br>   (2)使用输入输出流进行通信。<br>   (3)关闭Socket并释放有关的资源。</p>
<h5 id="2-3-相关类和方法的解析"><a href="#2-3-相关类和方法的解析" class="headerlink" title="2.3 相关类和方法的解析"></a>2.3 相关类和方法的解析</h5><p>(1)ServerSocket类<br>   java.net.ServerSocket类用于描述服务器套接字。<br>   ServerSocket(int port) - 根据参数指定的端口号来创建对象并绑定。<br>   Socket accept() - 监听并接收客户端的连接请求，若无客户端连接则进入等待状态。<br>   void close() - 用于关闭套接字。</p>
<p>(2)Socket类<br>   java.net.Socket类用于描述客户端套接字。套接字是两台机器间通信的端点。<br>   Socket(String host, int port) - 根据参数指定的IP地址和端口号创建对象。<br>   InputStream getInputStream() - 用于获取当前套接字的输入流。<br>   OutputStream getOutputStream() - 用于获取当前套接字的输出流。<br>void close() - 用于关闭套接字。</p>
<h4 id="3-tcp协议和udp协议的比较"><a href="#3-tcp协议和udp协议的比较" class="headerlink" title="3.tcp协议和udp协议的比较"></a>3.tcp协议和udp协议的比较</h4><p>（a）tcp协议<br>   tcp协议 - 传输控制协议，是一种面向连接的协议，类似于打电话。</p>
<pre><code>- 建立连接 =&gt; 进行通信  =&gt; 断开连接
- 在通信的整个过程中全程保持连接
- 保证了数据传递的可靠性和有序性    
- 是一种全双工的字节流通信方式
- 服务器压力比较大，资源消耗比较多，而且数据传递的效率相对比较低。
</code></pre><p>（b）udp协议<br>   udp协议 - 用户数据报协议，是一种非面向连接的协议，类似于写信。</p>
<pre><code>- 在通信的整个过程中不需要保持连接。
- 不保证数据传递的可靠性和有序性
- 是一种全双工的数据报通信方式
- 服务器压力比较小，资源消耗比较少，但数据传递的效率相对比较高。
</code></pre><h4 id="4-基于udp协议的编程模型-重点"><a href="#4-基于udp协议的编程模型-重点" class="headerlink" title="4.基于udp协议的编程模型(重点)"></a>4.基于udp协议的编程模型(重点)</h4><h5 id="4-1-编程模型"><a href="#4-1-编程模型" class="headerlink" title="4.1 编程模型"></a>4.1 编程模型</h5><p>主机A(接收方):<br>   (1)创建DatagramSocket类型的对象，并与参数指定的端口绑定。<br>   (2)创建DatagramPacket类型的对象，等待接收数据。<br>   (3)调用receive()方法来接收数据。<br>   (4)关闭Socket并释放有关的资源。</p>
<p>主机B(发送方):<br>   (1)创建DatagramSocket类型的对象。<br>   (2)创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号。<br>   (3)调用send()方法来发送数据。<br>   (4)关闭Socket并释放有关的资源。</p>
<h5 id="4-2-相关类和方法的解析"><a href="#4-2-相关类和方法的解析" class="headerlink" title="4.2 相关类和方法的解析"></a>4.2 相关类和方法的解析</h5><p>(1)DatagramSocket类<br>   java.net.DatagramSocket类用于描述发送或接收数据报的套接字，也就是包裹投递/接收点<br>   DatagramSocket() - 使用无参的形式构造对象。<br>   DatagramSocket(int port) - 根据参数指定的端口号来构造对象。<br>   void receive(DatagramPacket p) - 用于接收数据并存放到参数指定的包裹中。<br>   void send(DatagramPacket p) - 用于将参数指定的包裹发送出去。<br>   void close() - 关闭套接字并释放有关的资源。</p>
<p>(2)DatagramPacket类<br>   java.net.DatagramPacket类用于描述数据报信息的。<br>   DatagramPacket(byte[] buf, int length) </p>
<pre><code>- 用于构造一个能接收长度为length的数据包，将数据存放在buf中。
</code></pre><p>   DatagramPacket(byte[] buf, int length, InetAddress address, int port) </p>
<pre><code>- 用于构造一个将长度为length的数据报，发送给主机address上的port端口。
</code></pre><p>   InetAddress getAddress() - 用于获取发送方/接收方的IP地址信息。<br>   int getPort() - 用于获取发送方/接收方的端口号信息。<br>   int getLength() - 用于获取发送/接收的数据长度。</p>
<p>(3)InetAddress类<br>   java.net.InetAddress类用于描述互联网协议地址，也就是IP地址信息。<br>   static InetAddress getLocalHost() - 用于获取本地主机的地址信息。<br>   static InetAddress getByName(String host) - 用于根据主机名来获取地址信息。<br>   String getHostName() - 用于获取主机名信息并返回。<br>   String getHostAddress() - 用于获取ip地址信息并返回。  </p>
<h3 id="第十五章-反射"><a href="#第十五章-反射" class="headerlink" title="第十五章  反射"></a>第十五章  反射</h3><h4 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如：</span><br><span class="line">   Person p = new Person();   - 在运行阶段只能创建Person类型的对象</span><br><span class="line">   p.show();                  - 在运行阶段只能调用show()方法</span><br></pre></td></tr></table></figure>
<ul>
<li>反射本质上就是一种实现动态编程的机制，也就是说在运行阶段才能确定创建何种类型的对象以及调用何种方法的机制，具体的类型和方法由实参决定。</li>
<li><p>目前主流的框架技术底层都是采用反射机制实现的。</p>
<h4 id="2-Class类"><a href="#2-Class类" class="headerlink" title="2. Class类"></a>2. Class类</h4><h5 id="2-1-基本概念-3"><a href="#2-1-基本概念-3" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h5></li>
<li>Class类的实例表示正在运行的Java应用程序中的类和接口，也就是代表一种数据类型。</li>
<li><p>Class类没有公共构造方法，Class类的实例是在类加载的过程中由Java虚拟机和类加载器自动构造的。</p>
<h5 id="2-2-获取Class类实例-对象的主要方式"><a href="#2-2-获取Class类实例-对象的主要方式" class="headerlink" title="2.2 获取Class类实例/对象的主要方式"></a>2.2 获取Class类实例/对象的主要方式</h5></li>
<li>a.使用数据类型.class的方式来获取对应的Class对象。 </li>
<li>b.使用对象.getClass()方法的调用来获取对应的Class对象。</li>
<li>c.使用包装类.TYPE的方式可以获取对应基本类型的Class对象。</li>
<li>d.使用Class.forName()的方式来获取参数指定类型的Class对象。  </li>
<li>总结：基本数据类型：a和c  引用数据类型：a和b和d <h5 id="2-3-常用的方法"><a href="#2-3-常用的方法" class="headerlink" title="2.3 常用的方法"></a>2.3 常用的方法</h5></li>
<li>T - 由此 Class 对象建模的类的类型（要实例化的对象类型）</li>
<li>static Class&lt;?&gt; forName(String className) - 用于获取参数指定类型的Class对象。</li>
<li>T newInstance() - 使用当前正在调用对象所代表的类来构造新对象。<ul>
<li>若当前正在调用对象代表String类，调用此方法就相当于new String()来构造对象。</li>
<li>若当前正在调用对象代表Person类，调用此方法就相当于new Person()来构造对象。</li>
</ul>
</li>
<li>Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes) <ul>
<li>用于获取当前正在调用对象所代表的类中参数指定的单个公共构造方法并返回。</li>
</ul>
</t></li>
<li>Constructor&lt;?&gt;[] getConstructors() <ul>
<li>用于获取当前正在调用对象所代表的类中所有的公共构造方法并返回。</li>
</ul>
</li>
<li>Field getDeclaredField(String name) <ul>
<li>用于获取当前正在调用对象所代表的类中参数指定的单个成员变量并返回。</li>
</ul>
</li>
<li>Field[] getDeclaredFields() <ul>
<li>用于获取当前正在调用对象所代表的类中所有的成员变量并返回。</li>
</ul>
</li>
<li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes) <ul>
<li>用于获取当前正在调用对象所代表的类中参数指定的单个公共成员方法并返回。</li>
</ul>
</li>
<li><p>Method[] getMethods() </p>
<ul>
<li>用于获取当前正在调用对象所代表的类中所有的公共成员方法并返回。</li>
</ul>
<h4 id="3-Constructor类"><a href="#3-Constructor类" class="headerlink" title="3. Constructor类"></a>3. Constructor类</h4><h5 id="3-1-基本概念-2"><a href="#3-1-基本概念-2" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h5></li>
<li><p>java.lang.reflect.Constructor<t>类用于描述获取到的单个构造方法。</t></p>
<h5 id="3-2-常用的方法-1"><a href="#3-2-常用的方法-1" class="headerlink" title="3.2 常用的方法"></a>3.2 常用的方法</h5><p>T newInstance(Object… initargs)     </p>
<ul>
<li>用于当前正在调用对象所代表的构造方法来构造新实例，参数进行新实例初始化工作<br>参数(Object… initargs):  其中…代表可变长参数，<br>initargs - 将作为变量传递给构造方法调用的对象数组；基本类型的值被包装在适当类型的包装器对象（如 Float 中的 float）中。<br>例如: (Object… initargs)就是  (“zhangfei”, 30)<br>Class c1 = Class.forName(“xdl.day21.Person”);//获得class<br>Constructor ct = c1.getConstructor(String.class, int.class);//获得Constructor类ct<br>System.out.println(ct.newInstance(“zhangfei”, 30)); //用ct构造新实例</li>
</ul>
</li>
</ul>
<h4 id="4-Field类"><a href="#4-Field类" class="headerlink" title="4 Field类"></a>4 Field类</h4><h5 id="4-1基本概念"><a href="#4-1基本概念" class="headerlink" title="4.1基本概念"></a>4.1基本概念</h5><p>   java.lang.reflect.Field类用于描述获取到的单个成员变量。</p>
<h5 id="4-2常用的方法"><a href="#4-2常用的方法" class="headerlink" title="4.2常用的方法"></a>4.2常用的方法</h5><p>   Object get(Object obj) </p>
<pre><code>- 用于获取对象obj中当前正在调用对象所代表成员变量的数值并返回。 
- 若参数传入Person类型的p对象，当前正在调用的对象代表成员变量name时，
  调用该方法表示返回p.name的数值。 
</code></pre><p>   void set(Object obj, Object value) </p>
<pre><code>- 用于将obj对象中当前正在调用对象所代表成员变量的数值修改为value。
- 若参数传入Person类型的p对象，当前正在调用的对象代表成员变量name时，
  调用该方法则表示p.name = value的效果。
</code></pre><p>   void setAccessible(boolean flag)</p>
<pre><code>- 用于设置是否进行Java语言的访问检查，若给true则表示取消检查。 
</code></pre><h4 id="5-Method类"><a href="#5-Method类" class="headerlink" title="5 Method类"></a>5 Method类</h4><h5 id="5-1基本概念-1"><a href="#5-1基本概念-1" class="headerlink" title="5.1基本概念"></a>5.1基本概念</h5><p>   java.lang.reflect.Method类用于描述获取到的单个成员方法。</p>
<h5 id="5-2常用的方法"><a href="#5-2常用的方法" class="headerlink" title="5.2常用的方法"></a>5.2常用的方法</h5><p>   Object invoke(Object obj, Object… args) </p>
<pre><code>- 用于使用obj对象调用当前正在调用对象所代表的成员方法，实参传递args并返回。
- 若参数传入Person类型的p对象，当前正在调用的对象代表成员方法getName()时，调用该方法则表示p.getName(args)的效果。
</code></pre><h4 id="6-JavaBean的概念"><a href="#6-JavaBean的概念" class="headerlink" title="6. JavaBean的概念"></a>6. JavaBean的概念</h4><p>  JavaBean本质上就是一种习惯性的编程规范，并不是明确的编程规则/语法要求，具体如下：<br>     (1)要求遵循JavaBean规范的类必须在一个包中；<br>     (2)要求遵循JavaBean规范的类必须有无参的构造方法；<br>     (3)要求遵循JavaBean规范的类必须私有化成员变量；<br>     (4)要求遵循JavaBean规范的类必须提供公有的get和set成员方法;<br>     (5)要求遵循JavaBean规范的类支持序列化操作；</p>
<h3 id="第十六章设计原则、模式"><a href="#第十六章设计原则、模式" class="headerlink" title="第十六章设计原则、模式"></a>第十六章设计原则、模式</h3><p>示例代码：<br>D:\兄弟连视频day21\code\</p>
<h4 id="1-设计原则"><a href="#1-设计原则" class="headerlink" title="1. 设计原则"></a>1. 设计原则</h4><h5 id="1-1-项目-软件开发的流程"><a href="#1-1-项目-软件开发的流程" class="headerlink" title="1.1 项目/软件开发的流程"></a>1.1 项目/软件开发的流程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    需求分析文档 =&gt; 概要设计文档 =&gt; 详细设计文档 =&gt; 编码和测试 =&gt; 安装和调试</span><br><span class="line">=&gt; 维护和升级</span><br></pre></td></tr></table></figure>
<h5 id="1-2-常用的设计原则"><a href="#1-2-常用的设计原则" class="headerlink" title="1.2 常用的设计原则"></a>1.2 常用的设计原则</h5><p><a href="http://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html" target="_blank" rel="noopener">http://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">(1)开闭原则（Open Close Principle  OCP）</span><br><span class="line">- 对扩展开放，对修改关闭。</span><br><span class="line">                   - 为了保证程序的可维护性和复用性更高，尽量避免错误的发生。</span><br><span class="line">                   - 任何软件都是bug(臭虫、漏洞)的。</span><br><span class="line">如：</span><br><span class="line">   public class Person&#123;                  </span><br><span class="line">      private String name;</span><br><span class="line">      ... ...  </span><br><span class="line">   &#125;   </span><br><span class="line"></span><br><span class="line">   public class SubPerson extends Person&#123;</span><br><span class="line">      private int age;</span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">(2)里氏代换原则（Liskov Substitution Principle  LSP）</span><br><span class="line"> - 任何父类可以出现的地方，子类一定可以出现。</span><br><span class="line">  - 子类 is a 父类，体现在继承和多态方面。</span><br><span class="line">如：</span><br><span class="line">   public class TestShape&#123;</span><br><span class="line">       public void draw(Shape s)&#123;</span><br><span class="line">           s.show();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   TestShape ts = new TestShape();</span><br><span class="line">   ts.draw(new Circle(1, 2, 3));</span><br><span class="line">   </span><br><span class="line">(3) 依赖倒转原则（Dependence Inversion Principle  DIP）</span><br><span class="line">- 尽量依赖于抽象类和接口，而不是具体实现类。</span><br><span class="line">- 抽象类和接口对子类具有强制性和规范性。</span><br><span class="line">如：</span><br><span class="line">   public abstract class A&#123;</span><br><span class="line">      void show();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class B extends A&#123;</span><br><span class="line">      @Override</span><br><span class="line">      void show()&#123;</span><br><span class="line">           ....</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> (4)接口隔离原则（Interface Segregation Principle  ISP）</span><br><span class="line">- 尽量依赖于小接口而不是大接口，避免接口的污染。</span><br><span class="line">如：</span><br><span class="line">   public interface RunAnimal&#123;  </span><br><span class="line">       public void run();</span><br><span class="line">   &#125;</span><br><span class="line">   public interface FlyAnimal&#123;</span><br><span class="line">       public void fly();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   public class Dog implements RunAnimal&#123;</span><br><span class="line">       public void run()&#123;  ...&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> (5) 迪米特法则（Demeter Principle最少知道原则）（DP）</span><br><span class="line">- 高内聚，低耦合。</span><br><span class="line">       - 内聚就是指一个实体/模块尽量将该模块需要具备的所有功能都聚集在内部。</span><br><span class="line">       - 耦合就是指一个实体/模块尽量少于其他实体/模块有关联。</span><br><span class="line">      </span><br><span class="line">(6)合成复用原则（Composite Reuse Principle  CRP）</span><br><span class="line">- 尽量使用合成的原则，而少使用继承。</span><br><span class="line">如：</span><br><span class="line">   public class A&#123;</span><br><span class="line">      public void show()&#123; ... ...&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class B&#123;</span><br><span class="line">      A a;</span><br><span class="line">      public B(A a)&#123;</span><br><span class="line">         this.a = a;</span><br><span class="line">      &#125;</span><br><span class="line">      public void test()&#123;</span><br><span class="line">          //调用A类中的show()方法</span><br><span class="line">          a.show();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-常用的设计模式"><a href="#2-常用的设计模式" class="headerlink" title="2.常用的设计模式"></a>2.常用的设计模式</h4><h5 id="2-1-基本概念-4"><a href="#2-1-基本概念-4" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h5><p><a href="http://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html" target="_blank" rel="noopener">http://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html</a><br>   设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。<br>   通俗来说，就是使用在固定场合中的固定套路。</p>
<h5 id="2-2-基本分类"><a href="#2-2-基本分类" class="headerlink" title="2.2 基本分类"></a>2.2 基本分类</h5><p>   创建型模式 - 工厂方法模式、抽象工厂模式、单例设计模式、…(要求会写)<br>   结构型模式 - 装饰器模式、代理模式、…(要求看懂)<br>   行为型模式 - 模板方法模式、观察者模式、…(以后讲到)      </p>
<h5 id="2-3-工厂方法（Factory-Method）"><a href="#2-3-工厂方法（Factory-Method）" class="headerlink" title="2.3 工厂方法（Factory Method）"></a>2.3 工厂方法（Factory Method）</h5><ul>
<li>用途：工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种(普通的工厂方法)如果传入的字符串有误，不能正确创建对象，第二种(静态工厂)相对于第一种，不需要实例化工厂类，所以，大多数情况下，我们会选用第二种——静态工厂方法模式。</li>
<li><p>普通工厂模式(Normal Factory)，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图：<br><img src="http://dl.iteye.com/upload/attachment/0083/1180/421a1a3f-6777-3bca-85d7-00fc60c1ae8b.png" alt="普通工厂"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">步骤<span class="number">1</span>：新建Sender接口</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">步骤<span class="number">2</span>：新建两个实现Sender接口的实现类 EmsSender和MailSender</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"EmsSender"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"MailSender"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">步骤三:新建工厂类SendFactory 提供获得接口实现类的方法</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(type.equals(<span class="string">"ems"</span>))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> EmsSender();</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"mail"</span>))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">步骤四:测试代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SendFactory sendFactory = <span class="keyword">new</span> SendFactory();</span><br><span class="line">		String type = <span class="string">"ems"</span>;</span><br><span class="line">		Sender sender = sendFactory.produce(type);<span class="comment">// 获得工厂对象</span></span><br><span class="line">		sender.sender();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态工厂模式(Normal Factory)</p>
<ul>
<li>将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">步骤一和步骤二同上</span><br><span class="line">步骤三:新建一个工厂对象 提供静态的方法用于获取接口实现类</span><br><span class="line">public class StaticFactory &#123;</span><br><span class="line">	</span><br><span class="line">	public static Sender emsSender()&#123;</span><br><span class="line">		return new EmsSender();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static Sender mailSender()&#123;</span><br><span class="line">		return new MailSender();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">步骤四: 测试</span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		StaticFactory.emsSender().sender();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>抽象工厂模式（Abstract Factory）。</p>
<ul>
<li>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。因为抽象工厂不太好理解，我们先看看图，然后写代码，就比较容易理解。<br><img src="http://dl.iteye.com/upload/attachment/0083/1185/34a0f8de-16e0-3cd5-9f69-257fcb2be742.jpg" alt="抽象工厂模式"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">步骤一和步骤二同上</span><br><span class="line">步骤三：提供一个Provider接口可以获得工厂方法的实现类</span><br><span class="line">public interface Provider &#123;</span><br><span class="line">	Sender produce();</span><br><span class="line">&#125;</span><br><span class="line">步骤四：提供具体的抽象方法实现Provider接口</span><br><span class="line">public class SendEmsFactory implements Provider &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Sender produce() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return new EmsSender();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SendMailFactory implements Provider &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Sender produce() &#123;</span><br><span class="line">		return new MailSender();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">步骤五：测试</span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Provider  provider = new SendMailFactory();</span><br><span class="line">		Sender mail = provider.produce();</span><br><span class="line">		mail.sender();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-4-单例模式（Singleton）"><a href="#2-4-单例模式（Singleton）" class="headerlink" title="2.4 单例模式（Singleton）"></a>2.4 单例模式（Singleton）</h5></li>
<li>用途：</li>
<li><p>在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：</p>
<ul>
<li>1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。</li>
<li>2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</li>
<li>3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//饿汉式</span><br><span class="line">//public class Singleton &#123;</span><br><span class="line">//	//1、私有化构造方法 该方法只能在内部使用</span><br><span class="line">//	private Singleton()&#123;//默认调用父类的构造方法</span><br><span class="line">//	&#125;</span><br><span class="line">//	</span><br><span class="line">//	//2、私有化类成员变量 提供本类的引用指向本类的对象</span><br><span class="line">//	private static Singleton singleton = new Singleton();//饿汉式 一开始就声明</span><br><span class="line">//</span><br><span class="line">//	//提供 公有的get方法</span><br><span class="line">//	public static Singleton getSingleton()&#123;</span><br><span class="line">//		return singleton;</span><br><span class="line">//	&#125;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 懒汉式</span><br><span class="line">public class Singleton &#123;</span><br><span class="line">	// 1、私有化构造方法 该方法只能在内部使用</span><br><span class="line">	private Singleton() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 2、私有化类成员变量 提供本类的引用指向本类的对象</span><br><span class="line">	private static Singleton singleton=null;</span><br><span class="line"></span><br><span class="line">	// 提供 公有的get方法 静态方法 类名.直接调用</span><br><span class="line">	public static Singleton getSingleton() &#123;</span><br><span class="line">		if (singleton == null) &#123;// 如果没有生成过 那么调用构造器</span><br><span class="line">			singleton = new Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		return singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程安全版本。</span><br><span class="line">public class Singleton &#123;</span><br><span class="line">	// 1、私有化构造方法 该方法只能在内部使用</span><br><span class="line">	private Singleton() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 2、私有化类成员变量 提供本类的引用指向本类的对象</span><br><span class="line">	private static Singleton singleton = null;</span><br><span class="line"></span><br><span class="line">	//初始化方法加锁 线程安全</span><br><span class="line">	public static synchronized void initSingleton() &#123;</span><br><span class="line">		if (singleton == null) &#123;// 如果没有生成过 那么调用构造器</span><br><span class="line">			singleton = new Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 提供 公有的get方法 静态方法 类名.直接调用</span><br><span class="line">	public static Singleton getSingleton() &#123;</span><br><span class="line">		if (singleton == null) &#123;</span><br><span class="line">			initSingleton();</span><br><span class="line">		&#125;</span><br><span class="line">		return singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-5-适配器模式（Adapter）"><a href="#2-5-适配器模式（Adapter）" class="headerlink" title="2.5 适配器模式（Adapter）"></a>2.5 适配器模式（Adapter）</h5></li>
<li>用途：适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。首先，我们来看看类的适配器模式，先看类图：<img src="http://dl.iteye.com/upload/attachment/0083/1189/6b2d13aa-7cc7-3e98-9764-bdcb2c64f795.jpg" alt="适配器模式"></li>
<li><p>核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">步骤一:定义一个Source类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">source</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"source的方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">步骤二: 定义一个扩展接口</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">source</span><span class="params">()</span></span>;<span class="comment">//包含待适配类的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">target</span><span class="params">()</span></span>;<span class="comment">//待适配方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">步骤三:Adapter适配器类实现接口继承Source类 重写待适配方法</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Targetable</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">target</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"这是适配器Adapter的适配方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-6-装饰者模式（Decorator）"><a href="#2-6-装饰者模式（Decorator）" class="headerlink" title="2.6 装饰者模式（Decorator）"></a>2.6 装饰者模式（Decorator）</h5></li>
<li>用途：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，关系图如下：<img src="http://dl.iteye.com/upload/attachment/0083/1195/e1b8b6a3-0150-31ae-8f77-7c3d888b6f80.jpg" alt="装饰者模式"></li>
<li><p>优点：<br>　　1. 装饰模式可以提供比继承更多地灵活性。<br>　　2. 可以通过一种动态的方式来扩展一个对象的功能，在运行时选择不同的装饰器，从而实现不同的行为。<br>　　3. 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。<br>　　4. 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。</p>
</li>
<li><p>缺点：<br>　　1. 会产生很多的小对象（具体装饰类），增加了系统的复杂性。<br>　　2. 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">步骤一:定义一个Sourceable接口</span><br><span class="line">public interface Sourceable &#123;</span><br><span class="line">	void method();</span><br><span class="line">&#125;</span><br><span class="line">步骤二:装饰类和被装饰类都实现上述接口,装饰对象持有被装饰对象的实例</span><br><span class="line">public class Source implements Sourceable&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void method() &#123;</span><br><span class="line">		System.out.println(&quot;这个是Source的方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Decorator implements Sourceable&#123;</span><br><span class="line"></span><br><span class="line">	private Source source;</span><br><span class="line">	</span><br><span class="line">	public Decorator(Source source)&#123;</span><br><span class="line">		super();</span><br><span class="line">		this.source = source;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void method() &#123;</span><br><span class="line">		System.out.println(&quot;装饰前的方法&quot;);</span><br><span class="line">		source.method();</span><br><span class="line">		System.out.println(&quot;装饰后的方法&quot;);	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">步骤三:测试</span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Source source = new Source();</span><br><span class="line">		Decorator decorator = new Decorator(source);</span><br><span class="line">		decorator.method();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-7-代理模式（Proxy）"><a href="#2-7-代理模式（Proxy）" class="headerlink" title="2.7 代理模式（Proxy）"></a>2.7 代理模式（Proxy）</h5></li>
<li>用途：代理模式就是多一个代理类出来，替原对象进行一些操作。代理模式使用到极致开发就是AOP。代理分：静态代理，动态代理(JDK默认代理，兄弟关系)，CGLIB代理(子类代理)。</li>
<li><p>代理模式的应用场景：<br>如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：<br>1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。<br>2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。<br><img src="http://dl.iteye.com/upload/attachment/0083/1197/ea094ad9-efc5-337d-a8e8-ce9223511144.jpg" alt="代理模式"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">步骤一:新建接口</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">步骤二:对象实现接口</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"这个是Source类的原始方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">步骤三:代理类 持有被代理对象</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Source source;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.source = <span class="keyword">new</span> Source();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		before();</span><br><span class="line">		source.method();</span><br><span class="line">		after();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"代理类的before方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"代理类的after方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">步骤四：测试</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">		proxy.method();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="X-常见算法"><a href="#X-常见算法" class="headerlink" title="X.常见算法"></a>X.常见算法</h4><p>示例代码：</p>
<h5 id="1-常用的查找算法-重点"><a href="#1-常用的查找算法-重点" class="headerlink" title="1.常用的查找算法(重点)"></a>1.常用的查找算法(重点)</h5><h3 id="1-1-线性查找算法-顺序查找算法"><a href="#1-1-线性查找算法-顺序查找算法" class="headerlink" title="### 1.1 线性查找算法(顺序查找算法)"></a>### 1.1 线性查找算法(顺序查找算法)</h3><p>(1)算法流程<br>a.使用目标元素与样本数列中的第一个元素起依次进行比较；<br>b.若找到与目标元素相等的元素，则表示查找成功；<br>c.若目标元素与样本数列中的所有元素都比较完毕也没找到相等的元素，则表示查找失败；</p>
<h3 id="1-2-二分查找算法-折半查找算法"><a href="#1-2-二分查找算法-折半查找算法" class="headerlink" title="### 1.2 二分查找算法(折半查找算法)"></a>### 1.2 二分查找算法(折半查找算法)</h3><p>示例代码：D:\兄弟连视频day22\code\TestFind.java<br>(1)算法流程<br>a.假定样本数列中的元素都是从小到大排列的；<br>b.使用目标元素与样本数列中的中间元素比较大小，若相等则表示查找成功；<br>c.若目标元素小于中间元素，则去中间元素的左边进行查找，重复步骤b；<br>d.若目标元素大于中间元素，则去中间元素的右边进行查找，重复步骤b；<br>e.若目标元素与所有该比较元素比较完毕后也没有相等的元素，则表示查找失败； </p>
<h5 id="2-常用的排序算法-重点"><a href="#2-常用的排序算法-重点" class="headerlink" title="2.常用的排序算法(重点)"></a>2.常用的排序算法(重点)</h5><h3 id="2-1-冒泡排序算法-重中之重"><a href="#2-1-冒泡排序算法-重中之重" class="headerlink" title="### 2.1 冒泡排序算法(重中之重)"></a>### 2.1 冒泡排序算法(重中之重)</h3><p>示例代码：</p>
</li>
</ul>
<p>(1)算法流程<br>   a.比较相邻位置的两个元素，若第一个元素比较大则交换两个元素的位置；<br>   b.从开始的第一对一直到结尾最后一对，经过这一步最后的元素将是这组元素中的最大值；<br>   c.重复步骤b持续对越来越少的元素进行两两比较，直到处理完毕所有元素为止；<br>     (直到任意两个相邻位置的元素都无需发生交换为止) </p>
<h3 id="2-2-插入排序算法-熟悉"><a href="#2-2-插入排序算法-熟悉" class="headerlink" title="### 2.2 插入排序算法(熟悉)"></a>### 2.2 插入排序算法(熟悉)</h3><p>(1)算法流程<br>  a.从第一个元素起，认定该元素已经有序；<br>  b.取出下一个元素与左边的有序数列从右向左依次进行比较；<br>  c.若取出的元素小于左边的元素，则将左边的元素右移；<br>  d.重复步骤c，直到取出元素大于等于左边的元素时，则将取出的元素插入到左边元素的右边   e.重复步骤b，直到处理完毕所有元素为止；</p>
<h3 id="2-3-选择排序算法-熟悉"><a href="#2-3-选择排序算法-熟悉" class="headerlink" title="### 2.3 选择排序算法(熟悉)"></a>### 2.3 选择排序算法(熟悉)</h3><p>(1)算法流程<br>   a.从第一个元素起依次取出，并且假定取出的元素为这一组元素中的最小值，<br>     使用min记录下标；<br>   b.使用min记录的元素与后续元素依次比较大小；<br>   c.若找到了比min记录的元素还小的元素，则使用min变量重新记录该元素的下标；<br>   d.直到min记录的元素与后续所有元素比较完毕后，交换min记录的元素与最开始假定的<br>     元素，经过这一步最前面的元素将是这组元素中的最小值；<br>   e.重复步骤a，直到处理完毕所有元素为止；</p>
<h3 id="2-4-快速排序算法-重点"><a href="#2-4-快速排序算法-重点" class="headerlink" title="### 2.4 快速排序算法(重点)"></a>### 2.4 快速排序算法(重点)</h3><p>(1)算法流程<br>   a.找到样本数列中的中间元素作为基准值单独保存起来；<br>   b.分别使用左右两边的元素与基准值比较大小，将所有比基准值小的元素放在基准值<br>     的左边，将所有比基准值大和相等的元素放到基准值的右边，这个过程叫做分组；<br>   c.经过这一步，左边的元素小于基准值，右边的元素大于等于基准值，但左右两边<br>     的分组内部不一定有序，此时需要对左右两边的分组进行再次分组；<br>   d.直到处理完毕所有元素为止；</p>
<h4 id="常见面试题："><a href="#常见面试题：" class="headerlink" title="常见面试题："></a>常见面试题：</h4><ol>
<li>wait()和 sleep()区别：<br><a href="http://www.cnblogs.com/renhui/p/6069353.html" target="_blank" rel="noopener">http://www.cnblogs.com/renhui/p/6069353.html</a><br>解释：<br>sleep(有参数)方法是Thread类里面的，主要的意义就是让当前线程停止执行，让出cpu给其他的线程，但是不会释放对象锁资源以及监控的状态，当指定的时间到了之后又会自动恢复运行状态。<br>wait()方法是Object类里面的，主要的意义就是让线程放弃当前的对象的锁，进入等待此对象的等待锁定池，只有针对此对象调动notify方法后本线程才能够进入对象锁定池准备获取对象锁进入运行状态。<br>区别是：<br>(a)sleep()有参数：毫秒            wait()无参数<br>(b)sleep()睡眠时，保持对象锁，仍然占有该锁；而wait()睡眠时，释放对象锁。<br>但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。</li>
<li>final, finally ,finalize<br><a href="http://www.cnblogs.com/xiaomoxian/p/5184520.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaomoxian/p/5184520.html</a><br>final：关键字通常指的是“无法改变的”<br>final可以修饰变量（必须给赋值且值不能更改）、方法（无法被重写）和类（无法被继承）。<br>finally:关键字。对于一些代码，可能会希望无论try块中的异常是否抛出，它们都能够执行。这通常适用于善后（内存回收之外）的工作。<br>finalize():方法。垃圾回收器准备释放内存的时候，会先调用finalize()。<pre><code>(1).对象不一定会被回收。
(2).垃圾回收不是析构函数。
(3).垃圾回收只与内存有关。
</code></pre>  (4).Java GC（Garbage Collection，垃圾收集，垃圾回收）机制和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。</li>
<li>修饰词顺序：<br>[访问权限] [abstract] [static] [final] [transient] [volatile] [synchronized] [native] [strictfp]</li>
<li>run方法和start方法<br>java Thread中，run方法和start方法的区别，下面说法错误的是？<br>这里需要注意Thread的start（）与run（）方法：<br>用start（）方法才能真正启动线程，此时线程会处于就绪状态，一旦得到时间片，就会调用线程的run（）方法进入运行状态；<br>而run（）方法只是普通的方法，如果直接调用run（）方法，则会按照顺序执行主线程这一个线程<br>1.start方法<br>用 start方法来启动线程，是真正实现了多线程， 通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法。但要注意的是，此时无需等待run()方法执行完毕，即可继续执行下面的代码。所以run()方法并没有实现多线程。<br>2.run方法<br>run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码。</li>
</ol>
<p>5.Collection与Collections的区别？<br>java.util.Collection：<br>1、是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。<br>2、Collection接口在Java类库中有很多具体的实现。比如SET LIST<br>3、Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。<br>实例： public interface Collection<e> extends Iterable<e> {}<br>    List l1 = new LinkedList();  l1.add(new Name(“Kael”,”M”));<br>java.util.Collections：<br>1、是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。但是可以被调用。<br>实例:Collections.sort(l1);<br><a href="http://blog.csdn.net/hz_lizx/article/details/54909082" target="_blank" rel="noopener">http://blog.csdn.net/hz_lizx/article/details/54909082</a><br>6.构造器Constructor是否可被override(覆盖)？<br><a href="https://www.cnblogs.com/guweiwei/p/6596542.html" target="_blank" rel="noopener">https://www.cnblogs.com/guweiwei/p/6596542.html</a><br>构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。<br>Constructor不能被继承，所以Constructor也就不能被override。每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须负责在一开始调用父类的构造函数。<br>7.数组有没有length()这个方法？ String有没有length()这个方法？</e></e></p>
<p>数组有<br>static int    getLength(Object array)<br>          以 int 形式返回指定数组对象的长度。</p>
<p> String有<br> int    length()<br>          返回此字符串的长度。<br>8.什么是反射API？它是如何实现的？<br><a href="http://blog.csdn.net/BuddyUU/article/details/52458241" target="_blank" rel="noopener">http://blog.csdn.net/BuddyUU/article/details/52458241</a><br>在JDK中，主要由以下类来实现Java反射机制，这些类（除了第一个）都位于java.lang.reflect包中<br>　　Class类：代表一个类，位于java.lang包下。<br>　　Field类：代表类的成员变量（成员变量也称为类的属性）。<br>　　Method类：代表类的方法。<br>　　Constructor类：代表类的构造方法。<br>　　Array类：提供了动态创建数组，以及访问数组的元素的静态方法。<br>short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?<br><a href="http://bbs.itheima.com/thread-127149-1-1.html" target="_blank" rel="noopener">http://bbs.itheima.com/thread-127149-1-1.html</a><br>short s1 = 1; s1 = s1 + 1; 第二句Type mismatch: cannot convert from int to short 1默认为INT类型。<br>对于+=Java也会自动强转。对于b+＝1，Java会转成b = (short)(b+1)。<br>同样，对于+=Java也会自动强转。对于b+＝1，Java会转成b = (short)(b+1)<br>9.abstract class和interface有什么区别？<br> 抽象类{<br>抽象方法();<br>}只能被继承无法被实例化<br>Interface接口{<br>抽象方法和成员变量集合<br>}<br>1.一个类可以实现多个接口 ，但却只能继承最多一个抽象类。<br>2.抽象类可以包含具体的方法 ， 接口的所有方法都是抽象的。<br>3.抽象类可以声明和使用字段 ，接口则不能，但接口可以创建静态的final常量。<br>4.接口的方法都是public的，抽象类的方法可以是public，protected，private或者默认的package；<br>5.抽象类可以定义构造函数，接口却不能。<br>什么时候使用接口和抽象类？<br>看你想实现什么功能。使用抽象类是为了代码的复用，而使用接口的动机是为了实现多态性。</p>
<p>10.Integer和int的区别？<br>int 是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象<br>1.Java 中的数据类型分为基本数据类型和复杂数据类型<br>int 是前者而integer 是后者（也就是一个类）；因此在类进行初始化时int类的变量初始为0.而Integer的变量则初始化为null.<br>　int i =1；Integer i= new Integer(1);(要把integer 当做一个类看)；但由于有了自动装箱和拆箱　 (<a href="http://www.cnblogs.com/shenliang123/archive/2012/04/16/2451996.html)，" target="_blank" rel="noopener">http://www.cnblogs.com/shenliang123/archive/2012/04/16/2451996.html)，</a><br>　　使得对Integer类也可使用：Integer i= 1；　　　　<br>总而言之：如果我们定义一个int类型的数，只是用来进行一些加减乘除的运算or作为参数进行传递，那么就可以直接声明为int基本数据类型，但如果要像<br>对象一样来进行处理，那么就要用Integer来声明一个对象<br>11.JAVA内省机制<br><a href="http://blog.csdn.net/hahalzb/article/details/5972421" target="_blank" rel="noopener">http://blog.csdn.net/hahalzb/article/details/5972421</a><br>1).内省(Introspector)是Java 语言对Bean类属性、事件的一种缺省处理方法。例如类 A 中有属性 name, 那我们可以通过 getName,setName 来得到其值或者设置新的值。通过 getName/setName 来访问 name 属性，这就是默认的规则。 </p>
<p>JAVA内省反射机制三部曲：<a href="http://www.cnblogs.com/zqmingok/articles/1713520.html" target="_blank" rel="noopener">http://www.cnblogs.com/zqmingok/articles/1713520.html</a> </p>
<p>12.黑盒测试白盒测试<br>白盒测试：是通过程序的源代码进行测试而不使用用户界面。这种类型的测试需要从代码句法发现内部代码在算法，溢出，路径，条件等等中的缺点或者错误，进而加以修正。<br>黑盒测试：又被称为功能测试、数据驱动测试或基于规格说明的测试，是通过使用整个软件或某种软件功能来严格地测试, 而并没有通过检查程序的源代码或者很清楚地了解该软件的源代码程序具体是怎样设计的。测试人员通过输入他们的数据然后看输出的结果从而了解软件怎样工作。<br>13.hashcode和equals<br><a href="https://www.jianshu.com/p/893231579218" target="_blank" rel="noopener">https://www.jianshu.com/p/893231579218</a><br>1、如果两个对象相等（equals() 返回 true），那么它们的 hashCode()一定要相同；<br>2、如果两个对象hashCode()相等，它们并不一定相等（equals() 不一定返回 true）。<br>14.HashTable和HashMap的区别详解<br><a href="http://blog.csdn.net/fujiakai/article/details/51585767" target="_blank" rel="noopener">http://blog.csdn.net/fujiakai/article/details/51585767</a><br>HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。<br>      HashMap是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。<br>      HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。<br>二、Hashtable简介<br>      Hashtable同样是基于哈希表实现的，同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。<br>      Hashtable也是JDK1.0引入的类，是线程安全的，能用于多线程环境中。<br>      Hashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。<br>15.mybatis中#{}和${}的区别</p>
<ol>
<li>#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by “111”, 如果传入的值是id，则解析成的sql为order by “id”.
　　</li>
<li>$将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id,  如果传入的值是id，则解析成的sql为order by id.
　　</li>
<li>#方式能够很大程度防止sql注入。<br>　　<br>4.$方式无法防止Sql注入。</li>
</ol>
<p>5.$方式一般用于传入数据库对象，例如传入表名.<br>　　<br>6.一般能用#的就别用$.</p>
<p>MyBatis排序时使用order by 动态参数时需要注意，用$而不是#<br>16.redis、memcache、mongoDB有哪些区别<br><a href="https://segmentfault.com/q/1010000002588088" target="_blank" rel="noopener">https://segmentfault.com/q/1010000002588088</a><br>Memcached<br>Memcached的优点：<br>Memcached可以利用多核优势，单实例吞吐量极高，可以达到几十万QPS（取决于key、value的字节大小以及服务器硬件性能，日常环境中QPS高峰大约在4-6w左右）。适用于最大程度扛量。<br>支持直接配置为session handle。<br>坑少。<br>Memcached的局限性：<br>只支持简单的key/value数据结构，不像Redis可以支持丰富的数据类型。<br>无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。<br>无法进行数据同步，不能将MC中的数据迁移到其他MC实例中。<br>Memcached内存分配采用Slab Allocation机制管理内存，value大小分布差异较大时会造成内存利用率降低，并引发低利用率时依然出现踢出等问题。需要用户注重value设计。<br>Redis<br>Redis的优点：<br>支持多种数据结构，如 string（字符串）、 list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算）<br>支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。<br>支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。<br>单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。<br>支持pub/sub消息订阅机制，可以用来进行消息订阅与通知。<br>支持简单的事务需求，但业界使用场景很少，并不成熟。<br>Redis的局限性：<br>Redis只能使用单线程，性能受限于CPU性能，故单实例CPU最高才可能达到5-6wQPS每秒（取决于数据结构，数据大小以及服务器硬件性能，日常环境中QPS高峰大约在1-2w左右）。<br>支持简单的事务需求，但业界使用场景很少，并不成熟，既是优点也是缺点。<br>Redis在string类型上会消耗较多内存，可以使用dict（hash表）压缩存储以降低内存耗用。<br>：）以下是我个人的补充<br>Mc和Redis都是Key-Value类型，不适合在不同数据集之间建立关系，也不适合进行查询搜索。比如redis的keys pattern这种匹配操作，对redis的性能是灾难。<br>Mogodb<br>mogodb是一种文档性的数据库。先解释一下文档的数据库，即可以存放xml、json、bson类型系那个的数据。这些数据具备自述性（self-describing），呈现分层的树状数据结构。redis可以用hash存放简单关系型数据。<br>mogodb存放json格式数据。<br>适合场景：事件记录、内容管理或者博客平台，比如评论系统。<br>nosq的产品目前很多，架构师的选择导向主要有以下两个因素：<br>1）适合应用程序的使用场景，比如评论系统用比较适合使用mogodb，而mc也可以实现（应用程序把数据转化成json存入，但是部分数据更新不方便）<br>2）团队开发比较熟悉的技术，比如一个团队一直在使用mc，因而有限选择mc，而不是redis。<br>还有中严重的状况，开发团队一直使用mogodb，在适合kv nosq的场景下而继续选择mogodb。<br>17.Request中getContextPath、getServletPath、getRequestURI、request.getRealPath的区别。<br>假定你的web application 名称为news，你在浏览器中输入请求路径：<br><a href="http://localhost:8080/news/main/list.jsp" target="_blank" rel="noopener">http://localhost:8080/news/main/list.jsp</a><br>1.1 System.out.println(request.getContextPath());得到工程名<br>打印结果：/news1.2 System.out.println(request.getServletPath());得到当前页面所在目录下全名称<br>打印结果：/main/list.jsp<br>1.3 System.out.println(request.getRequestURI()); 得到包含工程名的当前页面全路径<br>打印结果：/news/main/list.jsp<br>1.4 System.out.println(request.getRealPath(“/“));  得到页面所在服务器的全路径：<br>打印结果：F:\Tomcat 6.0\webapps\news\test</p>
<ol start="18">
<li>4种创建线程池的方式。<br><a href="http://blog.csdn.net/yellowjianokok/article/details/52550257" target="_blank" rel="noopener">http://blog.csdn.net/yellowjianokok/article/details/52550257</a><br>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
</ol>
<p>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<p>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p>
<p>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<ol start="19">
<li>synchronized(class)、synchronized(this)与synchronized(object)<br>Synchronized：在多线程的情况下，由于同一进程的多个线程共享同一片存储空间，在带来方便的同时，也带来了访问冲突这个严重的问题。Java语言提供了专门机制以解决这种冲突，有效避免了同一个数据对象被多个线程同时访问。<br>JAVA中synchronized关键字能够作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。<br>synchronized void f() { /<em> body </em>/ } 和void f() { synchronized(this) { /<em> body </em>/ } }是完全等价的。<br>class与this的几种情况：<br>synchronized(class)<br>synchronized(this)</li>
</ol>
<p>线程各自获取monitor，不会有等待。<br>synchronized(this)<br>synchronized(this)</p>
<p>如果不同线程监视同一个实例对象，就会等待；如果不同的实例，不会等待。<br>synchronized(class)<br>synchronized(class)<br>如果不同线程监视同一个实例或者不同的实例对象，都会等待。</p>
<ol start="20">
<li>静态代码块(static block )作用<br>静态代码块(static block )，不包含在任何方法体中当类被载入时，自动执行静态代码块，且只被执行一次经常用于类属性的初始化。</li>
<li>类加载机制和双亲委派模型<br><a href="http://www.importnew.com/18548.html" target="_blank" rel="noopener">http://www.importnew.com/18548.html</a><br>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。如图所示。</li>
</ol>
<p>加载：<br>1.通过一个类的全限定名来获取定义此类的二进制字节流</p>
<ol start="2">
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；<br>连接：<br>1.验证：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br>2.准备：正式为类变量分配内存并设置类变量初始值的阶段，内存放在方法区。</li>
<li>解析：是虚拟机将常量池内的符号引用替换为直接引用的过程。<br>初始化：才真正开始执行类中定义的java程序代码。初始化阶段是执行类构造器<clinit>()方法。</clinit></li>
</ol>
<p>双亲委派模型：<br>从Java虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现（HotSpot虚拟机中），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都有Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。</p>
<p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<p>快捷键:<br>Eclipse常见快捷键:<br>重置Eclipse界面：Windows–Perspective–Reset Perspective 重置ECLIPSE</p>
<p>alt+/   : 代码联想 *</p>
<p>shift+alt+s:代码构建工具</p>
<p>ctrl+shift+x|y :切换选中字符大小写</p>
<p>ctrl+d : 删除鼠标所在当前行 * </p>
<p>ctrl+t : 查看选中类名的子父类结构 * </p>
<p>ctrl+o : 查看光标所在类的成员(方法,属性,代码块) *</p>
<p>alt+↑  : 光标所在行代码向上移动一行</p>
<p>alt+↓  : 光标所在行代码向下移动一行</p>
<p>ctrl+alt+↑ : 光标所在行代码向上复制一行 </p>
<p>ctrl+alt+↓ : 光标所在行代码向下复制一行</p>
<p>shift+回车 : 向当前光标所在位置的下一行插入一行空行, 并将光标移至新的空行中 (忽略代码的回车键) *</p>
<p>ctrl+1 : 帮助 * </p>
<p>ctrl+2 : 快捷变量的生成 * </p>
<p>ctrl+shift+o : 全局导包<br>开发工具快捷键<br>ctrl+N：新建<br>ctrl+1：提示错误信息<br>ctrl+D：删除<br>ctrl+/：行注释<br>ctrl+\：取消行注释<br>ctrl+shift+/：代码段注释<br>ctrl+shift+\：取消代码段注释<br>ctrl+H：快速查找任何文件信息、字符信息<br>ctrl+shift+O：导包<br>ctrl+T：查找类(支持模糊查找)<br>ctrl+R：查找文件（支持模糊查找、支持资源文件查找）<br>ctrl+shift+I：debug模式下，查看当前执行代码信息<br>ctrl+G：定位文件(不常用)</p>
<p>F5：进入方法内<br>F6：执行下一步<br>F7：跳出方法外<br>F8：执行到下一个断点</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/11/JAVA基础/" data-id="cjt5su7lu0000z8vyk2da76e1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/11/JAVA基础/">JAVA基础</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>